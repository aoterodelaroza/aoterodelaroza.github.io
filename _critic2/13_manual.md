---
layout: single
title: "Reference Manual"
permalink: /critic2/manual/
excerpt: "The critic2 reference manual."
sidebar:
  nav: "critic2_manual"
categories: critic2 manual
toc: true
toc_label: "External Libraries"
toc_sticky: false
classes: wide
---

## Overview

Critic2 is a program for the analysis and representation of electron
densities and other scalar fields in solids and molecules. It is able
to read the output generated by multiple solid-state and molecular
electronic structure programs, and to analyze, manipulate and
interconvert structures and scalar fields.

The original intent of critic2 was to analyze electron densities using
Bader's Quantum Theory of Atoms in Molecules (QTAIM). Some of
critic2's basic operations, for instance, are finding the critical
points of a scalar field (Bader's topology), or to find the attraction
basins of the maxima and integrate quantities in them (Bader's atomic
charges). In recent versions, however, critic2 has been extended to
support closely-related operations, such as manipulating and
interconverting structural formats, perform arithmetic operations on
scalar fields, calculate related quantities like STM images, calculate
NCI plots, and many, many more.

Within the QTAIM framework, critic2 also provides a host of
specialized algorithms: four different atomic basin integration
methods as well as a powerful and flexible automatic critical point
searching technique. Many scalar fields other than the electron
density are amenable to a QTAIM-style analysis (finding the topology
and integrating the attractor basins). These techniques (called
Quantum Chemical Topology, QCT, by P. Popelier) can be applied to a
variety of scalar fields including the ELF and the Laplacian of the
electron density. Critic2 can perform all these tasks for any field
either provided by the user or calculated inside the program.

A characteristic feature of critic2 is that it encapsulates common
operations and applies them, regardless of the electron density
source. If, for instance, one wants to calculate the critical points
of an electron density, the similar inputs and outputs are used and
obtained, regardless of whether the density comes from a gas-phase
calculation, a plane-wave code, or is described in terms of augmented
plane waves.

Critic2 was originally a program that only worked with electron
densities for periodic crystals. Support for molecular structures and
wavefunctions is quite good, but not as good as for crystals. In
particular, be aware that critic2 treats all systems---both crystals
and molecules---as if they were periodically repeated. The only
difference is that molecules are placed inside a very large repetition
cell. In principle, this is not a problem, but oddities and bugs may
be lurking.

Critic2 is described in Comput. Phys. Commun. 180 (2009), 157-166 and
Comput. Phys. Commun. 185 (2014), 1007-1018. Please, cite these
references if you find this program useful. The file THANKS contains a
complete list of contributors and other programs from where parts of
critic2 have been adapted.

## Installation

Please, see the README file. Particularly, note that the development
version of critic2 uses fairly modern Fortran, and you may need a
relatively recent Fortran compiler to use it.

## Command-line options, usage, and input overview

Critic2 accepts a single input file (usually but not necessarily
with extension .cri). The command-line syntax is:
~~~
$ critic2 [-q] [-h] [-r /path/to/critic2] ...
          [file.cri [file.cro]]
~~~
If both input and output files are present, the output is redirected
to file.cro. Otherwise, it is written to standard output. If no
file.cri is present, the input is taken from standard input. The input
and output extensions (cri and cro) are not mandatory. This is also
valid:
~~~
$ critic2 < file.cri > file.cro
~~~
Alternatively, you can use the standard input and standard output:
~~~
$ critic2
~~~
and then enter the commands by hand. In addition, depending on the
tasks in the input file, auxiliary files may be generated, usually
with the same root as file.cri ("file", in the example above) or
"stdin" if no input file is given.

The -h option ("help") prints a short help message and exits. The -q
option ("quiet") inhibits the initial and final messages. This is
useful when using critic2 in a pipe command. In addition, If no -q is
passed, a copy of each input line read by critic2 is written to the
output, preceded by a "%%" prefix. This helps identify the different
parts of the output. The -r option tells critic2 where to find its
data files. If /path/to/critic2 is given, the data files (wfc, dic,
etc.) should be in /path/to/critic2/dat.

The input file usually contains a specification of the crystal or
molecular structure using the CRYSTAL (see `The crystal structure`_)
or the MOLECULE (see `The molecular structure`_) keywords. For
instance:
~~~
CRYSTAL file.struct
~~~
After the structure is read, one or more fields are loaded using the
keyword LOAD. For instance:
~~~
LOAD file.clmsum file.struct
~~~
Unless otherwise stated, the default distance units in critic2, both
in input and output, are atomic units (bohr) for crystals and angstrom
for molecules. This can be changed using the UNITS keyword (see `Input
and output units`_). Electron densities are always in atomic units
(electrons/bohr^3).

After reading the structure and loading the relevant fields, specific
keywords are used to perform the required tasks. For instance, AUTO
(automatic determination of critical points), INTEGRALS (atomic
integration), NCIPLOT (non-covalent interaction index plots), etc.  A
concise description of the critic2 keyword syntax is given in the
syntax.txt file. If you are already familiar with this program, that
file will probably be more useful to you than this guide.

### Example set

You can find a collection of examples that demonstrate the usage and
features of critic2 in the examples/ subdirectory. The examples.txt
contains the whole list and a brief description of every example. The
input files mentioned contain more details inside.

xxxxxxxx

## Arithmetic expressions, variables, and functions in critic2

### Basic usage

In critic2, an arithmetic expression can be used almost everywhere in
the input where a real or integer number is expected. Arithmetic
expressions that appear in the input (without an associated keyword)
are evaluated and their result is written to the output. For instance,
you can start critic2 and write:
~~~
3+2*sin(pi/4)
%% 3+2*sin(pi/4)
   4.4142135623731
~~~
Similarly, variables can be defined and utilized in any
expression. Variable names must start with a letter and are composed
only of letters, numbers, and the underscore character. Also, they
cannot have the same name as a known constant (pi, e, eps) or a
function, regardless of case. Variables in expressions are
case-sensitive. To use a variable, first you need to assign it. For
instance:
~~~
a = 20+10
a/7 + 1
%% a/7 + 1
   5.2857142857143
~~~
By using the "-q" command-line option, critic2 can be used as a simple
calculator:
~~~
$ echo "1+erf($RANDOM/100000)" | critic2 -q
1.2578249310340
~~~
When used in combination with other keywords, arithmetic expressions
must be enclosed in either double quotes ("), single quotes ('), or
parentheses, or they must form a single word (i.e. no spaces). For
instance, this is valid critic2 input:
~~~
a = 0.12
NEQ 1/3 "2 / 3" 1/4+a Be
~~~
but this is not:
~~~
NEQ 1/3 2 /3 1/4 Be
~~~
because it contains one field too many (the space between 2 and /3 is
the problem). Arithmetic expressions can contain:

* Operators: +, -, *, /, ** or ^, % (modulo)

* Functions: see `List of available functions`_.

* Constants: pi, e and eps (the machine precision).

* Variables defined by the user as above.

* Structural variables. See `List of structural variables`_.

Parentheses can be used and the usual rules of associativity and
precedence apply.

In some cases, arithmetic expressions can be applied to make new
scalar fields by transforming existing fields. Scalar fields are
denoted with a dollar sign ($) followed by an identifier and,
optionally, a modifier. The default identifier for a field is the
order in which the field was loaded in the input. For instance, if the
first field ($1) is the spin-up density and the second ($2) is the
spin-down density, the total density can be calculated with the
expression "$1+$2". The expressions "$0" or "$rho0" represent the
promolecular density (which is always available once the crystal
structure is known) so "$1+$2-$rho0" would represent the density
difference between the actual crystal density and the sum of atomic
densities. Fields can also be referred by a name, if the ID keyword is
used (see `Loading a field (LOAD)`_ and `Additional LOAD
options`_). Named fields simplify the work if you load many fields.

It is possible to specify a field modifier right after the number or
name for that field in order to access its derivatives and other
properties related to that scalar field. The modifier, which is
separated by the field name using the ":" character and is case
insensitive, may be one of:

+ v: valence-only value of the field (it is usually employed to access
  the valence density in a grid field in which core augmentation is
  active).
+ c: core-only value of the field.
+ x, y, z: first derivatives.
+ xx, xy, yx, xz, zx, yy, yz, zy, zz: second derivatives.
+ g: norm of the gradient.
+ l: Laplacian.
+ lv: valence Laplacian (Laplacian without core augmentation).
+ lc: core Laplacian.

For instance, "$2:l" is the Laplacian of field 2 and "$rho0:xy" is the
xy-component of the Hessian of the promolecular density. In molecular
wavefunctions (wfn/wfx/fchk/molden), the value of particular orbitals
can be selected using the following field modifiers:

+ a number (<n>): selects molecular orbital number n. Thus, "$1:3"
  refers to the value of molecular orbital number 3 in field 1.
+ HOMO: the highest-occupied MO in an RHF wavefunction.
+ LUMO: the lowest-unoccupied MO in an RHF wavefunction.
+ AHOMO: the alpha highest-occupied MO in a UHF wavefunction.
+ ALUMO: the alpha lowest-unoccupied MO in a UHF wavefunction.
+ BHOMO: the beta highest-occupied MO in a UHF wavefunction.
+ BLUMO: the beta lowest-unoccupied MO in a UHF wavefunction.
+ A<n>: alpha MO number n in a UHF wavefunction.
+ B<n>: beta MO number n in a UHF wavefunction.

The flags that select virtual orbitals require a file format that
contains that information, and the field has to be loaded using the
READVIRTUAL keyword (see `Loading a field (LOAD)`_). Also in
unrestricted molecular wavefunction fields, one can access the spin
densities:

+ up,dn,sp: alpha, beta, and spin densities.

There is a clear distinction between expressions that reference fields
and those that do not and, for certain keywords, critic2 will decide
what to do with an expression based on this distinction. For
instance:
~~~
a = 2
CUBE CELL FIELD "a*$1"
~~~
calculates a grid spanning the entire cell for a scalar field that is
built as two times the value of field number 1, but:
~~~
a = 2
CUBE CELL FIELD "a*1"
~~~
uses field number two (a*1 = 2) to calculate the same
grid. Expressions involving fields can also be used in LOAD and in
other keywords (POINT, LINE, INTEGRABLE, etc.).

When using arithmetic expressions to create new fields, it is possible
to refer to coordinates in real space in those expressions by using
"structural variables". See `List of structural variables`_.

The value of a variable can be cleared using the CLEAR keyword:
~~~
CLEAR var1.s var2.s ...
CLEAR ALL
~~~
This keyword deletes the variables var1.s, var2.s, etc. or all the
variables (ALL). At any moment, the internal list of variables can be
printed to the output using the keyword LIST:
~~~
LIST
~~~
The LIST keyword lists all named variables and fields.

### Special fields

Some special fields are defined from the crystal (or molecular)
structure alone. For now, the only available special field is "ewald",
that can be accessed using "$ewald" in arithmetic expressions, and
gives the value of the Ewald potential using the current existing
charges (that can be set with the Q keyword, see `Atomic charge
options`_ for more information). For instance:
~~~
cube cell field "2 * $ewald"
~~~
calculates a grid using 2 times the value of the Ewald potential. 

### List of available functions

Arithmetic expressions can use any of the functions in the critic2
function library. These functions include the usual mathematical
functions (like exp or sin) but also functions that are meant to be
applied to scalar fields of a certain type (e.g., the Thomas-Fermi
kinetic energy density, gtf). It is very important to distinguish
whether a function expects a numerical argument (e.g. sin(x)), or a
field identifier (e.g. gtf(1) or gtf(rho0)).

The list of arithmetic functions is: abs, exp, sqrt, floor, ceil,
ceiling, round, log, log10, sin, asin, cos, acos, tan, atan, atan2,
sinh, cosh, erf, erfc, min, max. All these functions apply to numbers
(or other arithmetic expressions), and their behavior is the
usual. For instance, "sin(2*pi)", "max($1,0)", and "atan2(y,x)" are
all valid expressions.

The following "chemical" functions accept one or more field
identifiers as their arguments. Their purpose is to provide shorthands
to build fields from other fields using physically-relevant
formulas. For instance, "gtf(1)" is the Thomas-Fermi kinetic energy
density calculated using the electron density in field 1. In all
instances, "gtf(1)" is equivalent to writing the formula in full
("3/10*(3*pi^2)^(2d0/3d0)*$1^(5/3)") but, obviously, much more
convenient. Some of the chemical functions like, for instance, those
that require having access to the one-electron data, can only be used
with fields of a certain type.

In the lists below, the name in square brackets, if available, is a
shorthand for applying the chemical function to the reference field
(case-insensitive) in the POINTPROP keyword.

The following list of chemical functions can be used with any field
type. In all cases, field id must correspond to the system's electron
density.

* gtf(id) [GTF]: Thomas-Fermi kinetic energy density. The kinetic
  energy density for a uniform electron gas with its density given by
  the value of field id at the point.

  + Yang and Parr, Density-Functional Theory of Atoms and Molecules.

* vtf(id) [VTF]: the potential energy density calculated using the
  Thomas-Fermi kinetic energy density and the local virial theorem
  (2g(r) + v(r) = 1/4*lap(r) in au).

* htf(id) [HTF]: the total energy density calculated using the
  Thomas-Fermi kinetic energy density and the local virial theorem
  (2g(r) + v(r) = 1/4*lap(r) in au). The field id must contain the
  electron density of the system.

* gtf_kir(id) [GTF_KIR]: Thomas-Fermi kinetic energy density with the
  semiclassical gradient correction proposed by Kirzhnits for the
  not-so-homogeneous electron gas. The electron density and its
  derivatives are those of field id at every point in space. See:

  + Kirzhnits, (1957). Sov. Phys. JETP, 5, 64-72.

  + Kirzhnits, Field Theoretical Methods in Many-body Systems
    (Pergamon, New York, 1967).

  + Abramov, Y. A. Acta Cryst. A (1997) 264-272.

  and also:

  + Zhurova and Tsirelson, Acta Cryst. B (2002) 58, 567-575.

  + Espinosa et al., Chem. Phys. Lett. 285 (1998) 170-173.

  for more references and an example of the application of this
  quantity with experimental electron densities.

* vtf_kir(id) [VTF_KIR]: the potential energy density calculated using
  gtf_kir(id) and the local virial theorem (2g(r) + v(r) =
  1/4*lap(r) in au).

* htf_kir(id) [HTF_KIR]: the total energy density calculated using
  gtf_kir(id) and the local virial theorem (2g(r) + v(r) =
  1/4*lap(r) in au).

* lag(id) [LAG]: the Lagrangian density (-1/4 * lap(rho)).

* lol_ki(id) [LOL_KIR]: the localized-orbital locator (LOL) with the
  kinetic energy density calculated using the Thomas-Fermi
  approximation with Kirzhnits gradient correction. See:

  + Tsirelson and Stash, Acta Cryst. (2002) B58, 780.

The following functions require the kinetic energy density, and
therefore can only be used with fields that provide the one-electron
states. At present, this is only available for molecular wavefunction
fields. 

* gkin(id) [GKIN]: the kinetic energy density, G-version (grad(rho) *
  grad(rho)). See: 

  + Bader and Beddall, J. Chem. Phys. (1972) 56, 3320.

  + Bader and Essen, J. Chem. Phys. (1984) 80, 1943.

* kkin(id) [KKIN]: the kinetic energy density, K-version (rho *
  lap(rho)).

* vir(id) [VIR]: the electronic potential energy density, also called
  the virial field.

  + Keith et al. Int. J. Quantum Chem. (1996) 57, 183-198.

* he(id) [HE]: the electronic energy density, vir(id) + gkin(id).

* elf(id) [ELF]: the electron localization function (ELF).

  + Becke and Edgecombe J. Chem. Phys. (1990) 92, 5397-5403

* lol(id) [LOL]: the localized-orbital locator (LOL).

  + Schmider and Becke, J. Mol. Struct. (Theochem) (2000) 527, 51-61

  + Schmider and Becke, J. Chem. Phys. (2002) 116, 3184-3193.

* brhole_a1(id), brhole_a2(id), brhole_a(id): the A prefactor of the
  spherically averaged hole model proposd by Becke and Roussel
  (spin up, down, and average, respectively). The BR hole is an
  exponential A*exp(-alpha * r) at a distance b from the reference
  point. 

  + A.D. Becke and M.R. Roussel, Phys. Rev. A 39 (1989) 3761

* brhole_b1(id), brhole_b2(id), brhole_b(id): the b parameter of the
  BR hole model (spin up, down, and average). b is distance from the
  exponential center to the reference point.

* brhole_alf1(id), brhole_alf2(id), brhole_alf(id): the exponent of
  the BR hole model (spin up, down, and average).

* xhcurv1(id), xhcurv2(id), xhcurv(id): the curvature of the exchange
  hole at the reference point (spin up, down, and average). Q_sigma in
  the literature:

  + A.D. Becke and M.R. Roussel, Phys. Rev. A 39 (1989) 3761

* dsigs1(id), dsigs2(id), dsigs(id): the leading coefficient of the
  same-spin pair density (spin up, down, and average). D_sigma in the
  literature:

  + A.D. Becke and M.R. Roussel, Phys. Rev. A 39 (1989) 3761

The following chemical functions require both a molecular wavefunction
and basis set information (at present, this is only read from a
Gaussian fchk file). In addition, it is necessary to have critic2
compiled with the libCINT library to calculate the molecular integrals
involved (see README).

* mep(id): molecular electrostatic potential. 

* uslater(id): Slater potential U_x. The HF exchange energy is 
  the integral of rho times U_x. See:

  A.D. Becke, J. Chem. Phys. 138 (2013) 074109 and references therein.

* nheff(id): reverse BR efefctive hole normalization. See:

  A.D. Becke, J. Chem. Phys. 138 (2013) 074109 and references therein.

Other special labels can be used, that activate the calculation of
properties for the reference field. These are:

* stress: calculate the Schrodinger stress tensor of the reference
  field. The virial field is the trace of this tensor.

  + Keith et al. Int. J. Quantum Chem. (1996) 57, 183-198.

A particular case of chemical function is xc(), that allows the user
to access the external LIBXC library. This is only possible if the
LIBXC library was linked during the compilation of critic2. See `Use
of LIBXC in arithmetic expressions`_.

### Use of LIBXC in arithmetic expressions

If critic2 is linked to the libxc library (see the README for
instructions on how to do this) then the xc() function can be used in
arithmetic expressions. xc() calculates the exchange and/or
correlation energy density for one of the functionals in the libxc
library. The number of arguments to xc() depends on the type of
functional invoked, which is selected using an integer index. The list
of functionals available and their corresponding indices should be
consulted in the libxc documentation. The integer index that selects
the functional always appears *last* in the calling sequence of
xc(). For ease of reference, the files libxc_funcs_*.txt, specifying
the list of functionals in several versions of libxc, is included in
the doc/ directory.

The arguments to xc(...,idx) depend on the type of functional
specified by the idx integer, which can be:

* LDA: xc(rho,idx)

* GGA: xc(rho,grad,idx)

* meta-GGA: xc(rho,grad,lapl,tau,idx)

where rho is the electron density expression, grad is its gradient,
lapl is its Laplacian and tau is the kinetic energy density. Note that
rho, grad, lalp, and tau are *expressions*, not field identifiers like
in the chemical functions above. For instance, the expression for LDA
using the electron density loaded in field number 1 would be:
~~~
xc($1,1)+xc($1,9)
~~~
because idx=1 is Slater's exchange and idx=9 is Perdew-Zunger
correlation. PBE (a GGA) would be:
~~~
xc($1,$2,101)+xc($1,$2,130)
~~~
Here 101 is PBE exchange and 130 is PBE correlation. Field $1 contains
the electron density and $2 is its gradient, which can be determined
using, for instance:
~~~
LOAD AS GRAD 1
~~~
or, if the field is not a grid, in direct way by doing:
~~~
xc($1,$1:g,101)+xc($1,$1:g,130)
~~~

### List of structural variables

When creating new fields as transformations of existing fields, it is
possible to refer to the crystal or molecular structure (the nearest
atom, the position, etc.) using structural variables. Structural
variables start with the symbol "@" followed by an identifier that
select the type of variable. For some of the variables, an additional
modifier can be applied using the ":" symbol after the variable
identifier. For instance, "@dnuc" gives the distance to the nearest
nucleus. "@rho0nuc:3" is the atomic density at the given point of the
nearest atom number 3 (from the complete list). The following
structural variables are accepted in critic2:

* dnuc: Distance to the closest nucleus. By default, the distance is
  in angstrom for molecules and in bohr for crystals, unless changed
  using the UNITS keyword (see `Input and output units`_). (*)

* xnucx,ynucx,znucx: x,y,z coordinates of the nearest nucleus in
  crystallographic coordinates. (*)

* xnucc,ynucc,znucc: x,y,z coordinates of the nearest nucleus in
  Cartesian coordinates. By default, the coordinates have units of
  bohr in crystals, and are referred to the molecular center and have
  units of angstrom in molecules. (*)

* xx,yx,zx: the x,y,z coordinates of the point where the arithmetic
  expression is being evaluated (crystallographic coordinates).

* xc,yc,zc: the x,y,z coordinates of the point where the arithmetic
  expression is being evaluated. By default, the coordinates have
  units of bohr in crystals, and are referred to the molecular center
  and have units of angstrom in molecules. (*)

* xxr,yxr,zxr: the x,y,z coordinates of the point where the arithmetic
  expression is being evaluated (crystallographic coordinates in the
  reduced unit cell).

* idnuc: complete-list ID of the closest nucleus.

* nidnuc: non-equivalent list ID of the closest nucleus.

* rho0nuc: atomic density contribution from the nearest nucleus. (*)

* spcnuc: species ID of the nearest nucleus.

* zatnuc: atomic number of the closest nucleus.

Entries marked by a (*) at the end correspond to the structural
variables that accept a modifier. A modifieris a colon (:) followed by
a number id.i. If given, the modifier restricts the structural
variable to atoms with ID id.i (from the complete list). 

For instance, if we have a crystal structure and its electron density
in field $1 as a grid, then:
~~~
LOAD AS "(@idnuc == 1) * $1" ID voronoi
SUM VORONOI
~~~
calculates the Voronoi charge of atom 1. Likewise, this:
~~~
LOAD AS "@rho0nuc:1/$0 * $1" ID hirsh
SUM hirsh
~~~
calculates the Hirshfeld charge. Structural variables are also useful
in molecules in combination with the MOLCALC keyword. For instance, to
calculate the dipole moment of a neutral molecule (in units of
electrons*angstrom):
~~~
molcalc "$wfx * @xc"
molcalc "$wfx * @yc"
molcalc "$wfx * @zc"
~~~
Similar expressions can also be used to create new scalar fields by
restricting or modifying the values of a scalar field only in certain
areas of the system.

## The crystal structure

### Loading a crystal structure (CRYSTAL)

~~~
CRYSTAL file.cif [datablock.s]
CRYSTAL file.res
CRYSTAL file.ins
CRYSTAL file.cube
CRYSTAL file.bincube
CRYSTAL file.struct
CRYSTAL [file.]{POSCAR,CONTCAR,CHGCAR,CHG,ELFCAR,AECCAR0,
                AECCAR2} [at1.s at2.s ...|POTCAR]
CRYSTAL file_{DEN|PAWDEN|ELF|ELF|POT|VHA|VHXC|VXC|GDEN1|
              GDEN2|GDEN3|LDEN|KDEN}
CRYSTAL file.OUT # elk's GEOMETRY.OUT
CRYSTAL file.out [istruct.i] # ESPRESSO's PW output, file.scf.out
CRYSTAL file.out # crystal's output file.out
CRYSTAL file.in  # ESPRESSO's PW input, file.scf.in
CRYSTAL file.STRUCT_IN
CRYSTAL file.STRUCT_OUT
CRYSTAL file.gen
CRYSTAL file.xsf
CRYSTAL file.pwc
CRYSTAL
  SPG spg.s
  SPGR spg.s
  CELL a.r b.r c.r alpha.r beta.r gamma.r
  CARTESIAN [scal.r]
    # comment
    [BOHR|AU]
    [ANGSTROM|ANG]
    x1.r y1.r z1.r
    x2.r y2.r z2.r
    x3.r y3.r z3.r
  ENDCARTESIAN|END
  NEQ x.r y.r z.r at.s [ANG|ANGSTROM] [BOHR|AU]
  atom.s x.r y.r z.r [ANG/ANGSTROM] [BOHR/AU]
  atnumber.i x.r y.r z.r [ANG/ANGSTROM] [BOHR/AU]
  SYMM exprx.s, epxry.s, exprz.s
ENDCRYSTAL|END
CRYSTAL LIBRARY label.s
~~~
The first line of a critic2 input usually specifies the
structure. Critic2 can read a large number of crystal structure
formats. In the simplest usage, critic2 reads one of common file
formats like, for instance, a cif file. This is done by using:
~~~
CRYSTAL file.s
~~~
The extension of file.s is used to determine the appropriate reading
format. At present, critic2 understands cif files (extension .cif),
Gaussian cube files (.cube), critic2 binary cube files (.bincube),
WIEN2k's struct files (.struct), abinit density files (_DEN and
_PAWDEN), abinit files containing other scalar fields (_ELF,_LDEN,
etc.), elk's GEOMETRY.OUT (the .OUT extension is used, regardless of
whether the file name is GEOMETRY.OUT or not), Quantum ESPRESSO's pw.x
output (.out), Quantum ESPRESSO's pw.x input (.in), crystal's output
(.out), VASP's POSCAR, CONTCAR, CHGCAR, ELFCAR, AECCAR0, AECCAR2, and
CHG, siesta's STRUCT_IN (input) and STRUCT_OUT (generated by the
calculation), DFTB+'s gen files, xcrysden's xsf files, Quantum
ESPRESSO's pwc files, molecular xyz files, Gaussian's wfn, wfx, log,
and fchk files, and molden-style files.

The MOLECULE keyword can be used as a replacement for CRYSTAL in the
entries above. It is used when the structure correspond to a molecular
systems. For instance, cube files calculated with Gaussian (e.g. with
cubegen) can be used in critic2. See the `The molecular structure`_
section for more details.

The default distance units in the rest of the input and in the output
when CRYSTAL is used are atomic units (bohr). See `Input and output
units`_. 

A simple example of CRYSTAL input and the corresponding output
generated by critic2 is given in `Input and output for a simple
crystal structure`_.

#### Cube files (cube, bincube)

Gaussian cube files read using CRYSTAL are assumed to represent a
periodic system. For molecular cube files, see section `The molecular
structure`_. This format is used, for instance, by Quantum
ESPRESSO. 

Despite their name, cube files may be used to represent non-orthogonal
cells, and have become a de facto standard. They can be written by a
lot of popular solid-state programs, so it is a good choice if critic2
provides no native interface to the densities written in the native
format of your program.

Critic2 can be used to convert cube files to binary format in order to
save disk space and reading/writing time. Binary cube files have
extension .bincube, and contain essentially the same information as a
usual cube file.

#### WIEN2k (struct)

The structure of a crystal in WIEN2k is written to a file with
extension .struct. WIEN2k's struct files may or may not contain the
symmetry operations (for instance, if they have been generated by the
web interface but not run). 

#### VASP (POSCAR, CONTCAR, CHGCAR, CHG, AECCAR0, AECCAR2, ELFCAR)

In VASP, the crystal structure can be read from a number of files,
including the POSCAR (recommended), the CONTCAR, the CHGCAR, and
others. Depending on the version, VASP's POSCAR and CONTCAR (and also
the rest) may be missing the atomic symbols. In that case, they need
to be provided by hand after the file name, either using a list of
atomic symbols or the location of the POTCAR. Files that contain the
word POSCAR, CONTCAR, CHG, CHGCAR, AECCAR0, AECCAR2, and ELFCAR are
also accepted (e.g. nacl.POSCAR or POSCAR_nacl). Note that the
pseudopotential charges (ZPSP, see `Atomic charge options`_) are NOT
read from the POTCAR.

#### Elk (OUT)

In elk, the geometry is written to the GEOMETRY.OUT file. Any file
with extension .OUT will be assumed to be in elk's GEOMETRY.OUT format
(even though it may not be called GEOMETRY.OUT). The atomic numbers
are inferred from the name of the species file. The atomic names are
the symbols for those atomic numbers, with an integer suffix that
corresponds to the species file for that atom (first file = 1, second
file = 2, and so on).

#### Quantum ESPRESSO (scf.in, scf.out)

In addition to reading Gaussian cube files generated by Quantum
ESPRESSO, the outputs (extension .scf.out) and inputs (.scf.in) of
pw.x are also understood by critic2.

If an output (file.scf.out, butonly the .out extension is detected) is
used, the block at the beginning of the output is read (from 'Title:'
... to 'Cartesian axes'). By default, the last geometry in the file is
read. If the optional istruct.i integer is given, then read the
structure with that number (only for geometry optimization jobs)

For Quantum ESPRESSO inputs (file.scf.in), only the .in extension is
detected.

#### Crystal (out)

Crystal outputs can be read using the extension out. Critic2 will
automatically detect whether the file is a crystal or a Quantum
ESPRESSO output (which have the same "out" extension). Currently, only
periodic crystals are supported (no SLAB, POLYMER or MOLECULE). In
addition, this module has been tested for crystal06 and crystal14
only. 

#### CIF files (cif)

CIF files are the standard format for crystal structures in the
crystallography community. The standard is published by the
International Univon for Crystallography (the core CIF dictionary).
In critic2, CIF files are read using the ciftbx library by Sydney
R. Hall. If the CIF file provides the crystal symmetry, they are
read and used. 

CIF files can contain multiple structures in "data blocks". The
specific data block to read from a multi-block cif file can be
specified with the optional argument datablock.s. For instance, to
read the data_shelx block, use datablock.s = "shelx". If datablock.s
is not present, then the first block is read.

#### SHELX res and ins files (res, ins)

RES and INS files are generated and used by SHELX (and derivatives), a
program for the interpretation of experimental single-crystal X-ray
and neutron diffraction data. The INS (input) and RES (output) file
format specifications are almost identical, and can be found in the
SHELXL website. 

#### Abinit (DEN, PAWDEN, ELF, LDEN, etc.)

Abinit density files (with suffix "_DEN") and PAW valence density
files ("_PAWDEN") are binary files that, in addition to the electron
density grid, contain the structural information for the crystal. In
addition, other fields also generated by abinit (in the same format)
can be read, including the electron localization function (prtelf,
_ELF suffix), the Laplacian of the electron density (prtlden, _LDEN),
the exchange-correlation potentiatl (prtvxc, _VXC), the kinetic energy
density (usekden, prtkden, _KDEN), the Hartree potential (prtvha,
_VHA), the Hartree plus xc potential (prtvhxc, _VHXC), and the total
potential (prtpot, _POT).

#### SIESTA (STRUCT_IN and STRUCT_OUT)

The structure file generated by siesta has extension STRUCT_OUT. In
addition, the STRUCT_IN file (which has the same format) can be used
to restart SIESTA calculations.

#### Xcrysden (xsf)

Xcrysden generates scalar field files with extension xsf, which also
contain the crystal structure. If the xsf contains a crystal
structure, the PRIMVEC and PRIMCOORD cards are read - everything else
is ignored.

#### Quantum ESPRESSO wavefunction (pwc)

This file is generated by the pw2critic.x utility in the PP bundle of
Quantum ESPRESSO. The pwc file contains the structural information for
the system as well as the k-point information and the converged
Kohn-Sham states. It is mostly used in the calculation of
delocalization indices in periodic solids.

#### DFTB+ (gen)

DFTB+ reads and generates structures in the gen format. The gen format
can be read using the GenFormat driver in Geometry. It is also written
during geometry optimizations using OutputPrefix in Driver. The gen
format can be used for crystals (in which case it should contain the
lattice vectors at the end of the file) or molecules.

#### Manual specification of the crystal structure (CRYSTAL environment)

The crystal structure can be specified by hand using the CRYSTAL
environment. For instance, the input for magnesium oxide (rocksalt
structure) would be:
~~~
CRYSTAL
  SPG F m -3 m
  CELL 4.213 4.213 4.213 90 90 90 ANG
  NEQ 0. 0. 0. Mg
  NEQ 1/2 1/2 1/2 O
ENDCRYSTAL
~~~
There are several relevant keywords in the CRYSTAL environment. A
particular space group can be used with the SPG keyword, in which case
only the atoms in the asymmetric unit need to be given:
~~~
SPG spg.s
~~~
The SPG keyword builds the complete set of symmetry operations in the
crystal from the space group label alone. The space group names known
to critic2 correspond to those given in the International Tables for
Crystallography vol. A, in the Hermann-Mauguin notation. Each element
in the label is separated by one or more blanks, and the input is case
insensitive. Examples of values for spg.s are "F m -3 m", "P b a 2",
"P 1 n 1", "P 63 m c" (without the quotes).

If two origin choices are possible, then an additional token "1" or
"2" can be appended to the space group label to choose between
them. If no origin choice is specified, origin 1 is used by default
(note that in most electronic structure programs, origin 2 is
default, however). For example: "F d d d 1" (F d d d with origin
choice 1), "F d d d 2" (same group with origin choice 2), "F d d d"
(same as origin 1).

For R space groups, hexagonal and rhombohedral axes are
possible. These can be specified by an "h" or "r" token after the
space group label. If no "h" or "r" is given, hexagonal axes are
used. For the hexagonal, the obverse cell is used: (0 0 0),
(1/3,2/3,2/3), and (2/3,1/3,1/3). For instance, "R 3 h" (hexagonal
axes), "R 3 r" (rhombohedral axes), "R 3" (same as "R 3 h").

For monoclinic groups, when several unique axis choices (where all
have the same label), the tokens "b" and "c" choose between the
unique axis b and c respectively. By default, the b unique axis is
used. Example: "P 2 b" (unique axis b, same as "P 1 2 1"), "P 2 c"
(unique axis c, same as "P 1 1 2"), "P 2" (same as "P 2 b" and "P 1 2
1").

The space group label can also be given as a single word without
spaces. For instance, "Fm-3m" is the same as "F m -3 m". The space
group number can be used as well, in which case all defaults for
origin choice, unique axis and hexagonal/rhombohedral axes
apply. Example: "222" is equivalent to "Pn-3n", "Pn-3n1", and "P n -3
n 1".

If the space group is not one of the standard settings (for instance,
"A 2/n", also written as "A 1 2/n 1"), then the routines from the SPGR
library are used. These routines can be accessed direclty by using the
SPGR keyword instead of SPG:
~~~
SPGR spg.s
~~~
Even though the interpretation of the space group symbol is done by a
different library, the result is the same: establishing the symmetry
operations for the crystal.

The notation for SPGR is slightly different and provides more
flexibility than SPG (although space group numbers can not be
used). The space group label in SPGR follows these conventions: 

- Input space group symbol using the international Hermann-Mauguin
  notation for the operations.

- Each different symmetry element must be separated by a blank.

- Characters in a symmetry element must be given as a single
  word. This is also the case for subindices.

- Upperscore is represented by - preceding the symmetry operation.

- Case is irrelevant.

Examples of space groups for SPGR are "F m -3 m", "P 21 21 21", "A 1
21/n 1", "P 4/m m m", and "R -3 c".

If no SPG or SPGR keyword is found in the CRYSTAL environment, then an
internal routine calculates the symmetry from the atomic positions
(which can be deactivated using NOSYMM, see `Symmetry options`_). In
this case, all the atoms in the cell need to be given (in contrast to
using SPG, in which case only the asymmetric unit needs to be
given). There are two possible ways to input the cell parameters. In
the simplest approach, the CELL keyword can be used to give the cell
lengths and angles:
~~~
CELL a.r b.r c.r alpha.r beta.r gamma.r [ANG/ANGSTROM/BOHR/AU]
~~~
If the ANG (or ANGSTROM) keyword is used, then a.r, b.r and c.r are in
angstrom. Otherwise, cell parameters are in bohr by default (the
keyword BOHR or AU can be used, but it is redundant). Using the CELL
keyword lets critic2 decide on the crystallographic-to-Cartesian
transformation matrix (which is not unique; critic2 always uses the
Cholesky decomposition of the metric tensor, for
consistency). Alternatively, one could input this matrix using the
CARTESIAN keyword:
~~~
CARTESIAN [scal.r]
  # comment
  [BOHR/AU]
  [ANGSTROM/ANG]
  x1.r y1.r z1.r
  x2.r y2.r z2.r
  x3.r y3.r z3.r
ENDCARTESIAN/END
~~~
CARTESIAN reads the Cartesian coordinates of the cell vectors in some
arbitrary orthonormal reference frame. Each row corresponds to a
vector (hence the metric tensor is G = R * R' where R is the matrix
above and ' is the transpose, and the coordinate transformation is
(cryst) = (cart) * R). If scal.r is given, all vectors are scaled by
that factor. The input units are bohr by default. The default can be
changed with a previous UNITS command or with the BOHR/AU and
ANG/ANGSTROM keywords inside the CARTESIAN environment.

The CARTESIAN keyword is particularly useful for inputs based on
Quantum ESPRESSO results since the matrix corresponds exactly to the
CELL_PARAMETERS matrix, and scal.r can be set to celldm(1).

The NEQ keyword can be used to specify the atomic
positions. Equivalently, one can start the line with the atomic symbol
or the atomic number:
~~~
NEQ x.r y.r z.r at.s [ANG/ANGSTROM] [BOHR/AU]
atom.s x.r y.r z.r [ANG/ANGSTROM] [BOHR/AU]
atnumber.i x.r y.r z.r [ANG/ANGSTROM] [BOHR/AU]
~~~
NEQ adds one atom to the crystal. If symmetry is used (via SPG or
SYMM), then only the non-equivalent atom list needs to be given (as in
the MgO example above), which decreases the number of NEQs that are
necessary. Otherwise, the complete list of atoms in the cell has to be
indicated, and the symmetry guess will reduce it to the non-equivalent
atoms list. The coordinates x.r y.r z.r are crystallographic
(fractional) coordinates unless the ANG/ANGSTROM or BOHR/AU keywords
are used. Usage of Cartesian coordinates requires a previous CELL or
CARTESIAN command in order to convert the atomic positions to
crystallographic coordinates. The atomic symbol is at.s, and the
atomic number is detected from the symbol (essentially, from the
beginning of it, so atoms like Cl1 or baxx2 are valid). Deuterium (D)
is detected as hydrogen.

The list of atomic positions can be extended by symmetry operations
specified using the SYMM keyword. The SYMM keyword accepts three
arithmetic expressions separated by commas. These expressions contain
the variables x, y, and z (case insensitive), and represent symmetry
operations in crystallographic coordinates. For instance:
~~~
SYMM -X+1/2, Y+1/2, -Z+1/2
~~~
would apply that operation to all atoms in the NEQ. If they are
different from the original, the new atoms are added to the list. This
keyword is useful in cases when it is difficult to pass SPG a certain
non-standard setting for a low-symmetry space group, or when the
space group symmetry is given in this format instead of a space group
label (e.g. cif files and SHELX res files).

#### The crystal library (CRYSTAL LIBRARY)

A library of (simple) crystal structures is provided with critic2, and
can be accessed using the CRYSTAL LIBRARY keyword:
~~~
CRYSTAL LIBRARY NaCl
~~~
Critic2 tries to find the "NaCl" label (case-insensitive) in an
internal library file that is distributed with the code, and usually
located in dat/crystal.dat relative to the source of the
distribution. The relevant library entry in this case reads:
~~~
STRUCTURE B1 rock_salt rocksalt NaCl
  CRYSTAL
    SPG f m -3 m
    CELL 5.6402 5.6402 5.6402 90 90 90 ANG
    NEQ 0.0 0.0 0.0 na
    NEQ 0.5 0.5 0.5 cl
  ENDCRYSTAL
ENDSTRUCTURE
~~~
Note the four aliases (B1, rock_salt, rocksalt, and NaCl) that are
defined for the same crystal structure. The syntax in the CRYSTAL
environment is exactly the same as above.  The user can define their
own library of crystal structures either by modifying the crystal.dat
directly or by using the LIBRARY keyword:
~~~
LIBRARY CRYSTAL /path/to/library
~~~
where the indicated file is used instead to perform the lookup. The
path can be absolute or relative to the execution directory.

A similar library exists for molecules (molecule.dat) that can be
accessed throught the MOLECULE keyword. See `The molecular
structure`_.   

### Symmetry options

Critic2 has two symmetry modules: "spg" and "spglib". Spg accepts a
label (for instance, "P m -3 m") and builds the symmetry from
it. Spglib is a library by Atsushi Togo
(atztogo.github.io/spglib). Spglib reads the unit cell description
(lengths, angles, and the complete list of atoms in the cell) and
calculates all the symmetry operations. Spglib is always used,
regardless of whether the symmetry information is read from the
structure file (e.g. SPG keyword in CRYSTAL, or a cif file) or not. If
the system is big or the use of symmetry is specifically deactivated
(for instance if the crystal is too big), then the symmetry operations
from the external source will be used, if available.

The treatment of symmetry in critic2 can be controlled using the
SYMM/NOSYMM (before CRYSTAL) and CLEARSYM (after CRYSTAL) keywords.
~~~
SYM|SYMM [-1|0|1]
NOSYMM|NOSYM
~~~
Activates (SYM or SYMM) or deactivates (NOSYMM or NOSYM) the use of
symmetry. These keywords must be used before CRYSTAL to be effective,
and they have no effect on MOLECULE (molecules never use
symmetry). The four options to SYMM are: 0, no symmetry (same as
NOSYMM); 1, full symmetry; -1, use full symmetry only if the system is
small (<= 5000 atoms). The default is -1.
~~~
SYMPREC symprec.r
~~~
Sets the precision for the spglib symmetry module (default: 1d-4).
~~~
CLEARSYM
~~~
Clear all symmetry operations (that is, use space group P 1). It must
be used after CRYSTAL to be effective.

### Atomic charge options

The Q (or QAT) and ZPSP keywords can be used to change the atomic
charge and pseudopotential charge after CRYSTAL:
~~~
{Q|QAT} at1.s q1.r [at2.s q2.r] ...
ZPSP at1.s q1.r [at2.s q2.r] ...
~~~
This command changes the atomic charge (Q, QAT) or the pseudopotential
charge (ZPSP) of the atomic species at1.s, at2.s,.... Real numbers for
the charges and ZPSP are acceptable; the latter are internally
converted to integers.

Q is used to calculate the point-charge electrostatic energy (using
Ewald's method, see `Other structural tools (NEWCELL, ENVIRON,
PACKING, IDENTIFY, EWALD)`_).

The role of ZPSP is to augment the fields defined on a grid, a
procedure called core augmentation. ZPSP is the pseudopotential
charge, that is, the atomic number of the atom minus the number of
electrons represented by the pseudopotential. For instance, ZPSP=2 is
a usual value for Ba. A typical way to use grids in critic2 involves
loading the valence density or pseudo-density and augmenting it to an
all-electron density that has maxima at the nuclear positions, which
is important for certain applications (for instance, plotting).  While
this procedure is not entirely satisfactory from the theoretical point
of view, in practice, the valence regions are mostly unaffected. Of
course, core augmentation needs not be used if the field is not the
electron density or if the grid already contains the core
contributions, and it is usually better to use the full all-electron
density from the electronic structure code, if it is able to generate
it.

Core augmentation is not activated by default, even if the ZPSP
keyword is used (see CORE in `Additional LOAD options`_). The use of
ZPSP as above sets the pseudopotential charges for all current fields;
particular ZPSP values for certain fields can also be given using
LOAD. In a VASP calculation, the value of ZPSP can be found easily by
grepping 'ZVAL' in the POTCAR file. In Quantum ESPRESSO, this
information is in the UPF file (the "number of valence electrons"). In
abinit, it can be found in the pseudopotential files.

The keyword NOCORE clears the ZPSP values of all atoms in all fields:
~~~
NOCORE
~~~

### Loading multiple crystal structures

Critic2 can only work with one structure at a given time. However,
more than one crystal can be loaded in the same run, simply by giving
a new CRYSTAL (or MOLECULE) keyword. When the second and subsequent
CRYSTAL/MOLECULE keywords are read, critic2 clears all the information
for the previous structure, including the structural data (cell
parameters, atomic positions, etc.) as well as all the fields that had
been loaded, all the critical point information, and the atomic and
core density grids. Effectively, critic2 behaves as if starting a new
run, except in that the variables and global options are carried
over. To clear the variables and set the global options to their
default values, use the RESET keyword:
~~~
RESET
~~~

## The molecular structure

### Loading a molecular structure (MOLECULE)

~~~
MOLECULE file.xyz [border.r] [CUBIC|CUBE]
MOLECULE file.wfn [border.r] [CUBIC|CUBE]
MOLECULE file.wfx [border.r] [CUBIC|CUBE]
MOLECULE file.fchk [border.r] [CUBIC|CUBE]
MOLECULE file.molden [border.r] [CUBIC|CUBE]
MOLECULE file.log [border.r] [CUBIC|CUBE]
MOLECULE file.gen [border.r] [CUBIC|CUBE]
MOLECULE file.cube
MOLECULE file.bincube
MOLECULE file.cif
MOLECULE ...
MOLECULE
  NEQ x.r y.r z.r atom.s [ANG/ANGSTROM] [BOHR/AU]
  atom.s x.r y.r z.r [ANG/ANGSTROM] [BOHR/AU]
  atnumber.i x.r y.r z.r [ANG/ANGSTROM] [BOHR/AU]
  CUBIC|CUBE
  BORDER border.r
ENDMOLECULE/END
MOLECULE LIBRARY label.s
~~~

Critic2 can be used for gas-phase (isolated) molecules as well as
crystals. A molecular structure is loaded using the MOLECULE
keyword. The MOLECULE keyword is most often used for loading an xyz or
a similar molecular format, but the molecular geometry can also be given
directly in the input using the MOLECULE/ENDMOLECULE environment or
using any of the formats typically employed for crystals (cube, cif,
scf.in). All file formats valid in a CRYSTAL keyword (see `Loading a
crystal structure (CRYSTAL)`_) are also allowed in MOLECULE. As in the
CRYSTAL case, the file extension is used to interpret the file
format.

Because critic2 works under periodic boundary conditions, it does the
analysis of molecular structures by placing the molecule at the center
of a supercell large enough to encompass it. Provided the size of the
vacuum is large enough, the analysis should be carried out without
problems. The use of MOLECULE instead of CRYSTAL changes some of the
default behavior in critic2. Namely:

* The default distance units in input and output are angstrom instead
  of bohr (use the UNITS keyword in `Input and output units`_ to
  change this behavior). In particular, this applies to the Cartesian
  coordinates for the atoms in the MOLECULE environment and to the
  argument for BORDER. In the case of xyz, wfn, wfx, fchk, molden,
  gen, and cube files, the Cartesian coordinate system in input and
  output is the same as in the original file. Only the input
  orientation is read from Gaussian log (output) files,

* The use of spglib is automatically deactivated. All molecular
  structures are run in the P1 space group (or, rather, the C1
  molecular group).

* The default critical point search seeding strategy is modified (see
  `Finding critical points`_). In a crystal, a recursive subdivision
  of a symmetry-reduced portion of the Wigner-Seitz cell is used (SEED
  WS with DEPTH 1). In a molecule, the default is to seed at the
  center of every interatomic line between atom pairs less than 15
  bohr apart (SEED PAIR).

* In addition to the supercell, a second smaller cell is defined, the
  "molecular cell", that can be represented using the MOLCELL keyword
  in WRITE (`Exporting the structure (WRITE)`_) or CPREPORT
  (`Finding critical points`_). The region outside the molecular cell
  is assumed to be vacuum outside molecular space. Any CPs found
  outside the molecular cell are discarded, and all downwards gradient
  paths that exit the molecular cell are assumed to have diverged to
  infinity. See `Input and output for a simple molecular structure`_
  and `The molecular cell`_ for a more detailed explanation.

A simple example of MOLECULE input and the corresponding output
generated by critic2 is given in `Input and output for a simple
molecular structure`_.

Multiple molecular and crystal structures can be read in
succession. See `Loading multiple crystal structures`_. 

#### Molecular file formats (xyz, wfn, wfx, fchk, molden, log)

A gas-phase molecule can be input using an xyz file, a Gaussian
wfn/wfx file, a Gaussian output (log), a Gaussian formatted checkpoint
file (fchk), or a file in molden format (psi4, ADF, etc.). The
input molecule is enclosed in a parallelepiped that is larger
(default: 10 angstrom) in all directions than the minimal
parallelepiped encompassing the molecule. If the CUBIC (or CUBE)
keyword is given, then a cubic supercell is used. The width of the
vacumm around the molecule can be changed with the optional border.r
argument (by default in angstrom, the units can be changed with the
UNITS keyword). The molecule is automatically translated to the center
of the supercell.  The transformation from fractional coordinates
referred to the encompassing cell to Cartesian coordinates is made so
that the latter correspond to the original coordinate system in the
input file.  A molecular cell (that represents infinity in a gas-phase
system, see `Input and output for a simple molecular structure`_) is
chosen following the default procedure, see `The molecular cell`_.

#### DFTB+ gen format (gen)

A molecule can be read in DFTB+'s gen file format. If no lattice
vectors are provided, the optional border.r and CUBIC (or CUBE)
keyword can be used to control the size and shape of the encompassing
cell. The same considerations as for xyz files apply.  The coordinates
in critic2's input and output are the same as in the gen file.

#### Cube files (cube, bincube)

Cube files are also often used to describe molecular structures. For
instance, the cube files generated by Gaussian's cubegen program. As
in the case of xyz files, the Cartesian coordinate system in the rest
of the input and in the output is chosen so that it is the same as in
the cube file. A molecular cell is chosen by default (see `The
molecular cell`_).

Note that, contrary to xyz files, critic2 does not choose the size and
shape of the encompassing cell; the cell is given by the cube
file. Hence, the molecule is not translated by critic2, and it should
be centered for MOLECULE to work correctly.

Critic2 can be used to convert cube files to binary format in order to
save disk space and reading/writing time. Binary cube files have
extension .bincube, and contain essentially the same information as a
usual cube file.

#### Other crystallographic formats (cif, scf.in,...)

All CRYSTAL keywords can be replaced by MOLECULE and viceversa, with
the effect discussed above. The behavior of MOLECULE in this case is
essentially the same as in the case of a cube file: the encompassing
cell is taken from the file, and the molecule is not translated in any
way.

#### Manual specification of the molecular structure (MOLECULE environment)

A molecule can be specified directly in the input using the MOLECULE
environment. The atoms can be given in three different ways:
~~~
NEQ x.r y.r z.r atom.s [ANG/ANGSTROM] [BOHR/AU]
atom.s x.r y.r z.r [ANG/ANGSTROM] [BOHR/AU]
atnumber.i x.r y.r z.r [ANG/ANGSTROM] [BOHR/AU]
~~~
Each of these lines adds one atom to the molecule: the atom can be
given either with the NEQ keyword followed by the position and the
atomic symbol, or by putting the atomic symbol or the atomic number in
the first field. The position (x.r, y.r, z.r) must be given in
Cartesian coordinates. The units default to angstrom, but can be
changed using the ANG/ANGSTROM and BOHR/AU keywords, and also with the
global UNITS keyword (`Input and output units`_). 

The keywords CUBIC (or CUBE) and BORDER set the size and shape of the
encompassing supercell. This cell is taken as the minimal encompassing
cell plus a default border of 10 angstrom. This value can be changed
with the BORDER keyword (units: angstrom by default, unless changed by
the global UNITS keyword). The default cell is an orthogonal
parallelepiped: the three axes have different lengths. To make the
cell cubic, use the CUBE/CUBIC keyword.

#### The molecular library (MOLECULE LIBRARY)

A library of molecular structures is provided with critic2, and can be
accessed using the MOLECULE LIBRARY keyword:
~~~
MOLECULE LIBRARY h2o
~~~
The molecular library file is dat/molecule.dat, in the root of the
critic2 distribution. The location of the molecular library can be
changed using:
~~~
LIBRARY MOLECULE bleh.s
~~~
The behavior of the LIBRARY keyword is the same as in the CRYSTAL
case. See `The crystal library (CRYSTAL LIBRARY)`_ for more
information. 

## The molecular cell

In molecular calculations, it is convenient to define a region of
space, away from the molecule, that represents infinity. Critical
points in this region are discarded because the electron density (and
therefore the gradient) is zero everywhere. Gradient paths that reach
this region are terminated as if they had diverged to infinity.

In molecular systems, critic2 will reserve some space close to the
edges of the cell encompassing the molecule for this region. The
remaining (smaller) cell where the molecule is placed is called the
"molecular cell". 

When the MOLECULE keyword is used, a molecular cell is automatically
set up. By default, the molecular cell is chosen as the minimal
encompassing cell for the molecule plus 80% of the border or 2 bohr,
whichever is larger. Naturally, the molecular cell can not exceed the
actual cell. If the molecular structure is loaded from an external
file (xyz, wfn, etc.), then critic2 will set up both the encompassing
and the molecular cells correctly. If the structure source is a cube
or any other file format in which the encompassing cell is read from
the file, it is the users' responsibility to leave enough room for the
molecular cell.

The size of the molecular cell can be changed after the structure is
read using the MOLECELL keyword:
~~~
MOLCELL [border.r]
~~~
The MOLCELL keyword calculates the smallest parallelepiped
encompassing the molecular motif and then adds a border to it in order
to build the molecular cell. The default border is 10 angstrom, but
can be controlled by passing an additional numerical argument
(border.r, in the default distance units for the run, angstrom if you
used MOLECULE to read the structure). Using this keyword only makes
sense if the molecule is placed close to the center of the cell and if
there is an amount of vacuum between the molecule and the cell edges
enough to contain the molecular cell. In order to use MOLCELL, the
input structure needs to be read using the MOLECULE keyword and the
cell needs to be orthogonal.

## Exporting the structure (WRITE)

Critic2 can be used as a converter between different crystal structure
file formats. For instance, to convert a cif file to a QE input, we
can use:
~~~
CRYSTAL myfile.cif
WRITE myfile.scf.in
~~~
Sometimes, it is also useful to create a finite representation of a
crystal by taking the crystal motif, perhaps extended with some of
atoms in the neighboring cell. The simplest way of doing this is by
writing an xyz file:
~~~
CRYSTAL myfile_DEN
WRITE myfile.xyz MOLMOTIF
~~~
The MOLMOTIF keyword writes all atoms in the unit cell and completes
the molecules by using the atoms in the neighboring cells. A covalent
radii criterion is used to determine whether two atoms are bonded or
not (see the BONDFACTOR and RADII keywords in `Control commands and
options`_). The full syntax of the WRITE keyword is:
~~~
WRITE file.{xyz,gjf,cml} [SPHERE rad.r [x0.r y0.r z0.r]] 
      [CUBE side.r [x0.r y0.r z0.r]] [BORDER] [ix.i iy.i iz.i]
      [MOLMOTIF] [ONEMOTIF] [ENVIRON dist.r]
      [NMER nmer.i]
WRITE file.{obj,ply,off} [SPHERE rad.r [x0.r y0.r z0.r]] 
      [CUBE side.r [x0.r y0.r z0.r]] [BORDER] [ix.i iy.i iz.i] 
      [MOLMOTIF] [ONEMOTIF] [CELL] [MOLCELL] 
WRITE file.scf.in
WRITE file.tess
WRITE file.cri|file.incritic
WRITE {[file.]POSCAR|[file.]CONTCAR}
WRITE file.abin
WRITE file.elk
WRITE file.gau
WRITE file.cif
WRITE file.d12 [NOSYM|NOSYMM]
WRITE file.m
WRITE file.db
WRITE file.gin
WRITE file.lammps
WRITE file.fdf
WRITE file.STRUCT_IN
WRITE file.hsd
WRITE file.gen
~~~
A number of file formats can be written by critic2. As in CRYSTAL and
MOLECULE, the type of file is detected by the extension (xyz, in,
tess, cri, etc.). 

In the first WRITE command above, an xyz file containing a finite
piece of the crystal (if the structure was loaded with CRYSTAL) or the
molecule (resp. MOLECULE) is generated. Alternatively, if the gjf
extension is used, a template for a Gaussian input file is
written. The number of cells used in each direction is given by ix.i,
iy.i and iz.i (default: 1, 1, 1). For the purpose of its graphical
representation, it is sometimes interesting to include atoms which are
almost exactly at the edge of the cell. For instance, when doing:
~~~
CRYSTAL
  SPG f m -3 m
  CELL 5.64 5.64 5.64 90 90 90 ANG
  NEQ 0. 0. 0. na
  NEQ 1/2 1/2 1/2 cl
ENDCRYSTAL
WRITE nacl.xyz
~~~
Critic2 will (correctly) generate a list of 4 Na and 4 Cl atoms,
representing 1/8th of the conventional cell, because the atoms at (1,
0, 0), (1, 1/2, 0), etc. are repetitions of the atoms in the main
cell. However, this does not look good when the unit cell is
represented in a figure, because many of the atoms in the cubic cell
are "missing". By using BORDER, these atoms are included.

The SPHERE keyword writes all atoms inside a sphere of radius rad.r
(bohr) and centered around the crystallographic coordinates (x0.r y0.r
z0.r). In molecules, the default units for both the center and radius
of the sphere are Cartesian in angstrom. If no center is given,
(0,0,0) is used. The similar keyword CUBE writes all atoms inside a
cube of side side.r centered around (x0.r y0.r z0.r) (default:
(0,0,0)).

The keyword MOLMOTIF is used in molecular crystals. All atoms in the
requested crystal fragment are written to the xyz file. Then, the
molecules are completed using atoms from outside the fragment. In
order to do this, a connectivity criterion is used: two atoms are
bonded if their distance is less than BONDFACTOR times their sum of
covalent radii (see the BONDFACTOR and RADII keywords in `Control
commands and options`_).

The ONEMOTIF and ENVIRON keywords are also used in molecular
crystals. ONEMOTIF writes all atoms in the unit cell, translated by
lattice vectors to give connected molecules. ENVIRON writes the
molecular environment of the unit cell origin up to a distance renv.r
(bohr in crystals, angstrom in molecules). All connected molecules
whose center of mass is at a distance less than renv.r are written.

The NMER keyword is used in molecular systems as well, and in
combination with ONEMOTIF, MOLMOTIF, or ENVIRON. When NMER is given,
the selected fragment of the system is split into its component
connected molecules. Then, all monomers, dimers, trimers,... are
written to separate files. All n-mers are written from monomers up to
n-mers, where n is the value of nmer.i. In NMER is used with ENVIRON,
the first molecule in all n-mers except for those with n = nmer.i is
always part of the Wigner-Seitz cell, which is useful when generating
molecular environments of the crystal for calculations using
incremental methods.

There is an important application of the xyz-format WRITE keyword: the
coordinates written to the xyz file are consistent with the
transformation to Cartesian coordinates in critic2, so it is possible
to bring back all or part of these coordinates to critic2 in order to
represent a subset of the atoms in a crystal. This is very useful
when generating fragments for an NCIPLOT calculation (see FRAGMENT
keyword in section `Non-covalent interaction visualization
(NCIPLOT)`_).

The CML (Chemical Markup Language) format has the same options as the
xyz and obj output formats. In the CML format, an XML-style file is
written containing the selected crystal fragment. If the system is a
crystal (loaded with the CRYSTAL keyword), then the cell geometry is
written as well. The CML output format is specially tailored for being
easy to read by avogadro and its underlying engine, openbabel.

The OBJ output is similar to xyz: critic2 will write a finite piece of
the crystal or molecule to a file with Wavefront OBJ format. The OBJ
format is a three-dimensional model representation, that is, it uses
vertices and faces instead of atoms. This file format is understood by
many visualizers such as view3dscene, meshlab, blender, and
others. The keywords have the same meaning as in the xyz format. The
additional CELL keyword instructs critic2 to write a stick
representation of the unit cell. In a molecular structure, the MOLCELL
keyword can be used to represent the molecular cell (see `The
molecular cell`_). The similarly popular PLY (polygon file format or
Stanford triangle format) and OFF (Geomview) file formats can be used
as well, with the same options.

Quantum ESPRESSO inputs can be written using the extension
scf.in. This conversion is especially useful in the case of
low-symmetry crystals (e.g. monoclinic in a non-conventional setting)
where the conversion from other formats, such as CIF, can be
tricky. The QE input generation works by first determining the Bravais
lattice from the symmetry operations. Critic2 uses 'ibrav=0' always,
and writes a CELL_PARAMETERS block containing the
crystallographic-to-Cartesian transformation matrix. QE is particular
about how this matrix should written in order for its own symmetry
module to work. If the crystal setting matches any of those covered in
the QE manual, then that particular matrix is used. Otherwise, critic2
uses its own internal CELL_PARAMETERS matrix, which may result in
Quantum ESPRESSO failing to recognize the crystal symmetry. By
default, the crystal cell used by critic2 is written to the QE input
template. To reduce the cell to a primitive, use NEWCELL with the
PRIMITIVE keyword before writing the file.

A tessel input (extension .tess) and a critic2 input using the (.cri
or .incritic) can be written. Tessel is a program for crystal and
molecular plotting; it can be found at
http://azufre.quimica.uniovi.es. 

A VASP POSCAR (or CONTCAR) is generated by using the POSCAR/CONTCAR
extension or name. The list of atomic types is written to the critic2
output. This list is necessary to build the corresponding POTCAR. The
atoms are always ordered in increasing atomic number. An abinit input
file containing the input structure can be written by using the 'abin'
extension. An elk input template can be written using the elk
extension. A simple cif file (no symmetry) is generated if the cif
extension is used.

A template input file for crystal14 (incomplete - no basis set
specification) can be written with the extension d12. The generation
of these inputs uses the spglib symmetry routines to find the crystal
symmetry, and is still experimental. You should do NEWCELL PRIMITIVE
or NEWCELL STANDARD before writing a d12 file. The NOSYM (or NOSYMM)
option writes a template in the P1 space group.

A Gaussian input file for calculations under periodic boundary
conditions can be written using the gau extension. For a template
corresponding to a finite molecule, use gjf (see above).

The octave script file (extension .m) contains the structure in octave
format, to be read using the escher library (visit
http://schooner.chem.dal.ca for more information). The db file format
is intended for a set of automated input generation scripts written in
octave (https://github.com/aoterodelaroza/dcp).

A simple GULP template input file containing the structure (and EEM as
the first line) can be written using the .gin extension. No resonant
carbon atoms are detected.  For file names with an extension .lammps,
critic2 writes a simple LAMMPS data file containing one unit cell
(length units are angstrom). Only orthogonal cells are supported for
now. Both the GULP and the LAMMPS outputs are experimental, so please
exercise care and double-check the templates.

Two types of siesta inputs can be generated. The fdf extension writes
a template for a proper functional siesta input template containing
the crystal structure. The STRUCT_IN extension writes a files that can
be read using the MD.UseStructFile option.

Two inputs for DFTB+ may be written. The gen format contains only the
structure and is meant to be used with the GenFormat method in
Geometry. The hsd writes a fulll input template, including the
structure.

## Scalar fields

### Loading a field (LOAD)

Scalar fields are loaded with the LOAD keyword. A number of different
field formats are supported:
~~~
LOAD file.cube
LOAD file.bincube
LOAD file_{DEN|PAWDEN|ELF|ELF|POT|VHA|VHXC|VXC|GDEN1|
           GDEN2|GDEN3|LDEN|KDEN}
LOAD [file.]{CHGCAR|AECCAR0|AECCAR2}
LOAD {[file.]CHG|[file.]ELFCAR}
LOAD file.qub
LOAD file.xsf
LOAD file.grid
LOAD file.clmsum file.struct
LOAD file.{RHO,BADER,DRHO,LDOS,VT,VH}
LOAD file.OUT
LOAD STATE.OUT GEOMETRY.OUT
LOAD STATE.OUT GEOMETRY.OUT OTHER.OUT
LOAD file1.ion {nat1.i/at1.s} file2.ion ...
LOAD file.xml file.bin file.hsd
LOAD file.wfn
LOAD file.wfx
LOAD file.fchk [READVIRTUAL]
LOAD file.molden [READVIRTUAL]
LOAD file.pwc [file.chk [filedn.chk]]
LOAD COPY id.s [TO id2.s]
LOAD PROMOLECULAR
LOAD PROMOLECULAR [FRAGMENT file.xyz]
LOAD [WIEN|ELK|PI|CUBE|ABINIT|VASP|VASPCHG|QUB|XSF|ELKGRID|SIESTA|DFTB|
      WFN|WFX|MOLDEN|FCHK|PWC] file
LOAD ... [NEAREST|TRILINEAR|TRISPLINE|TRICUBIC] [EXACT|APPROXIMATE]
         [RHONORM|VNORM] [CORE|NOCORE] [NUMERICAL|ANALYTICAL]
         [TYPNUC {-3,-1,1,3}] [NORMALIZE n.r] [{NAME|ID} id.s]
         [NOTESTMT] [ZPSP at1.s q1.r...]
LOAD AS "expression.s" [n1.i n2.i n3.i|SIZEOF id.s|GHOST]
LOAD AS PROMOLECULAR {n1.i n2.i n3.i|SIZEOF id.s} 
        [FRAGMENT file.xyz]
LOAD AS CORE {n1.i n2.i n3.i|SIZEOF id.s}
LOAD AS LAP id.s
LOAD AS GRAD id.s
LOAD AS POT id.s [RY|RYDBERG]
LOAD AS CLM {ADD id1.s id2.s|SUB id1.s id2.s}
~~~
Critic2 loads scalar fields in "field slots": integer identifiers that
represent the field throughout the run. The NAME (or ID) keyword can
be used to assign a string identifier to a field as well. At the
beginning of the run, slot number 0 is occupied by the promolecular
density, which is automatically loaded right after the structure is
succesfully read. Successive LOAD commands fill the slots in
increasing order: the first LOAD will assign the new field to slot 1,
the second LOAD will occupy slot 2, and so on. By default, the first
loaded field (other than the promolecular density in slot 0) becomes
the reference field (see `The reference field (REFERENCE)`_).

The simplest usage of load is:
~~~
LOAD file.ext
~~~
The field information is read from file.ext. Critic2 uses the
extension to decide which format should be used for the reading:

* cube for Gaussian cube files (grid). Cube files can also be
  generated by programs other than Gaussian, for instance, Quantum
  ESPRESSO. They may correspond to a molecule or a periodic crysatl.

* Binary cube files (bincube) contain the same information as cube
  files but use a binary format. They can be generated by critic2.

* _DEN, _PAWDEN, _ELF,... for abinit grids.

* CHGCAR, AECCAR0, AECCAR2, CHG, or ELFCAR for VASP grids.

* qub for aimpac grids.

* xsf for xcrysden grids.

* grid for elk's grids (this requires a patch to elk, e-mail to
  request it).

* clmsum for WIEN2k.

* RHO, BADER, DRHO, LDOS, VT, and VH for SIESTA's grids.

* OUT for elk's STATE.OUT, ELF3D.OUT, RHO3D.OUT, etc.

* ion for aiPI ion files.

* xml for DFTB+'s detailed.xml.

* wfn, wfx, and fchk for Gaussian wavefunction files.

* molden for molecular wavefunction files (molden-style format). Both
  STO and GTO molecular wavefunctions are supported.

* pwc for the electron density plus Kohn-Sham state information from
  Quantum ESPRESSO, generated using the pw2critic.x program in
  PP/. Optionally, one or two checkpoint files from wannier90.

Specific details about each of these field types are given in the
following sections.

In some cases, the extension of the file to be loaded may be different
from the one that critic2 expects. For instance, WIEN2k creates files
with extensions other than clmsum for different fields (e.g. clmup for
the spin-up density) but the same format. In those cases, the keywords
WIEN/ELK/... can be used to force critic2 to read in a specific
format.

#### Cube files (cube, bincube)

Cube files can be generated by Gaussian's cubegen utility, but also by
other programs such as Quantum ESPRESSO. If the cube file corresponds
to a crystal structure, it is possible that it contains a
non-orthogonal grid (despite its name). Binary cube files (bincube)
are created by critic2.

#### Abinit density grids (DEN)

Density files generated by abinit come in a binary DEN format
(file_DEN or file_PAWDEN) and can be loaded by simply passing them to
LOAD. These files contain a grid of field values. Alternatively, other
files can be written using the "prt*" options in abinit, containing
different scalar fields in the same format, including the electron
localization function (prtelf, _ELF suffix), the Laplacian of the
electron density (prtlden, _LDEN), the exchange-correlation potentiatl
(prtvxc, _VXC), the kinetic energy density (usekden, prtkden, _KDEN),
the Hartree potential (prtvha, _VHA), the Hartree plus xc potential
(prtvhxc, _VHXC), and the total potential (prtpot, _POT).

#### VASP files (CHGCAR, AECCAR0, AECCAR2, CHG, ELFCAR)

VASP fields can come in two varieties. The CHGCAR and AECCAR* files
give the grid values in a higher precision and multiplied by the cell
volume. The CHGCAR can be read directly with LOAD and the AECCAR can
be read with something like:
~~~
LOAD VASP AECCAR0
~~~
The other format is the CHG, that is also used for the ELFCAR
(containing the values of the ELF function). In this case, the grid
values are given with less precision and they may or may not be
multiplied by the cell volume (depending on the VASP version). Both
can be loaded with:
~~~
LOAD CHG
LOAD ELFCAR
~~~
But if you have a file in this format that does not conform to those
names, you can use the VASPCHG keyword:
~~~
LOAD VASPCHG STRANGE_CHG_FILE_NAME.chg
~~~
The CHGCAR files are relatively safe to use, but CHGs data points may
or may not be multiplied by the unit cell volume, and you have to tell
critic2 which one it is. If you have a CHG file that is multiplied by
the volume, then you can force critic2 to load it in the same way as a
CHGCAR with:
~~~
LOAD VASP CHG
~~~
I have never seen an ELFCAR that is multiplied by the volume (it would
not make much sense anyway), so the default behavior for ELFCAR files
is to assume that it is not.

#### QE wavefunction plus Wannier checkpoint files (pwc)

The pwc file format is generated by the pw2critic utility in the
post-processing (PP) package of Quantum ESPRESSO. The pwc file
contains the crystal structure, k-point and plane-wave information,
the Kohn-Sham state coefficients, as well as the various mappings
necessary to use them. A field loaded using a pwc file corresponds to
the pseudo-valence density of the calculation, but the individual
Kohn-Sham states are read as well, which allows additional
calculations in critic2.

In particular, the LOAD command for the pwc file can be supplemented
with a second file (with extension chk) generated by Wannier90 during
the calculation of the maximally localized Wannier functions of the
system. A field loaded in this way can be used in the calculation of
delocalization indices in periodic systems. See
http://dx.doi.org/10.1021/acs.jctc.8b00549 and 
`Integrating delocalization indices in a solid with maximally localized Wannier functions`_
for more information. An additional file also generated by wannier90
is necessary to provide the MLWF orbital rotations in spin-polarized
systems. In that case, the first checkpoint file comes from the
up-spin wannier90 calculation and the second checkpoint file from the
down-spin wannier90 calculation. See the FeO case in the dis_wannier
example.

#### WIEN2k (clmsum, etc.)

In the case of WIEN2k, not all the necessary information is
encapsulated in the clmsum (for instance, the muffin tin radii are
missing), so it is necessary to provide a second file: the struct
file. This is the case, regardless of whether these same files were
used to load the structure in the CRYSTAL keyword.

If the file extension is not clmsum (e.g. clmup or clmdn), you can
force critic2 to use the WIEN2k interpreter by preceding the file name
with the keyword WIEN:
~~~
LOAD WIEN file.clmup
~~~
Some of these files (e.g. potentials) may have different
normalizations for the l=0 m=0 components in the muffins if they do
not represent electron densities (or spin densities). See RHONORM and
VNORM in `Additional LOAD options`_.

#### Elk (STATE.OUT and other OUT files)

There are three ways of loading a scalar field generated by elk. If a
single .OUT file is passed to critic2, then it is assumed to be a grid
generated by plot3d (tasks 33, 43, 53, and 63). The loaded scalar
field will be a three-dimensional grid of values (i.e. the same as a
cube file).

If two OUT files are passed to critic2, then it is assumed that the
first is the STATE.OUT and the second is the GEOMETRY.OUT for the
current elk calculation. As in the WIEN2k case, elk's STATE.OUT is
missing the structural information required to calculate the electron
density, which is why the GEOMETRY.OUT is necessary.

Elk's STATE.OUT is version-dependent. The following versions of elk
have been tested and work with critic2: 4.0.15, 2.3.22, 2.3.16,
2.2.10, 2.2.9, 2.2.8, 2.2.5, 2.2.1, 2.1.25, 2.1.22, 1.4.22, 1.4.18,
1.4.5, 1.3.31, 1.3.30, 1.3.24, 1.3.22, 1.3.20, 1.3.15, 1.3.2, 1.2.20,
1.2.15, 1.1.4, 1.0.17, 1.0.16, and 1.0.0. If your version is not
supported (most likely because it is newer; I tend to check this part
of the code every aeon or so), please contact me.

Using a patched version of elk it is possible to generate other files
(OTHER.OUT) containing the spherical harmonics/plane waves
representation of other fields, such as the elf and the Coulomb
potential. See the tools/elk_mod directory for the patch source
files. When the OTHER.OUT (e.g. ELF.OUT) file is passed as the third
argument to the LOAD command, then that field is loaded instead of the
density.

#### aiPI ion files (ion)

For aiPI inputs, several ion files are necessary. The ion files can be
associated to atoms either by using their non-equivalent atom number
(nat1.i) or the same atomic name as used in the crystal structure
specification (at1.s). 

#### DFTB+ files (xml file and others)

To load a field from the calcualted wavefunction using DFTB+, three
files are required: the detailed.xml file (written by the
WriteDetailedXML option), the eigenvec.bin file (using the
WriteEigenVectors options), and the file containing the wavefunction
coefficients, which has been provided by the authors of the DFTB+
package and can be obtained online:

  <http://www.dftb-plus.info/tools/waveplot>

The DFTB type is detected by the xml extension of the first file and,
therefore, the name of these files need not be "detailed.xml" or
"eigenvec.bin". 

Two different types of systems can be run in DFTB+: crystals under
periodic boundary conditions, and molecules in the gas-phase. In the
first case, if using k-points other than Gamma, the wavefunction is
complex, and the evaluation of the density is relatively slow,
comparable to aiPI. Molecules use real wavefunctions and they tend to
be less crowded than crystals, so using molecular DFTB fields should
be considerably faster. 

#### Gaussian wavefunction files (wfn/wfx)

Gaussian wavefunction files can be loaded by passing the wfn or wfx
file to critic2. This option is normally used in combination with
MOLECULE on the same file in order to obtain the same structure from
the isolated molcule. The evaluation of wfn/wfx densities and their
derivatives is analytical (no grids involved). If your file does not
have the wfn/wfx extension, you can force this format preceding the
file name with the WFN/WFX keyword.

A numerical field modifier can be used with molecular wavefunction
fields to select a particular molecular orbital. Thus, if a wfn/wfx
file is loaded in field 1, then "$1:4" selects the value of molecular
orbital number 4. Other labels such as HOMO and LUMO are also
available. See `Arithmetic expressions, variables, and functions in
critic2`_ for other field modifiers.

Supported wavefunction types: restricted (RHF), unrestricted (UHF),
and fractional occupation (MP2, etc.). Note that Gaussian wfn and wfx
files do not contain information about the virtual orbitals.

For molecular calculations that use effective core potentials (ECPs),
Gaussian provides the core density as a sum over atom-centered
Gaussian functions ("electron density functions"). These functions are
only present in a usable form in a wfx file, but not in the wfn
format. Hence, densities for molecules containing ECPs will be correct
and contain the core contribution only if the wavefunction is provided
to critic2 using the wfx format. If a wfx file is not available, core
augmentation using critic2's internal density tables is an option.

#### Gaussian formatted checkpoint files (fchk)

Similar to wfn/wfx, these files contain the molecular wavefunction
information. They should be used preferably in combination with
MOLECULE. The calculation of the density and related properties is
analytical. Numerical field modifiers can be used to select particular
molecular orbitals, same as in the wfn/wfx case. If your file does not
have the fchk extension, you can force this format preceding the file
name with the FCHK keyword.

Supported wavefunction types: restricted (RHF) and unrestricted
(UHF). 

Some parts of critic2 (the MOLCALC keyword and the orbital selector
option in arithmetic expressions) may use virtual orbitals if
available. By default critic2 will not read orbitals with zero
occupation. The virtual orbitals can be read by passing the
READVIRTUAL keyword to LOAD. This keyword only makes sense in formats
that contain virtual orbital information (fchk and molden).

#### Molecular molden-style files (molden)

Similar to wfn/wfx, these files contain the molecular wavefunction
information. They should be used preferably in combination with
MOLECULE. The calculation of the density and related properties is
analytical. Numerical field modifiers can be used to select particular
molecular orbitals. If your file does not have the molden extension,
you can force this format preceding the file name with the MOLDEN
keyword.

Molden files generated by different programs use slightly different
(and incompatible) versions of the same format, particularly regarding
normalization of the primitives. Recent versions of psi4 (~2016) have
been tested. ADF wavefunctions in terms of STO basis functions are
also supported (tested in 2017). If you try molden files from any
other program, please let me know how it went.

Supported wavefunction types: restricted (RHF) and unrestricted (UHF),
both with STO and GTO primitives. Virtual orbitals can be read using
the READVIRTUAL keyword.

Some parts of critic2 (the MOLCALC keyword and the orbital selector
option in arithmetic expressions) may use virtual orbitals if
available. By default critic2 will not read orbitals with zero
occupation. The virtual orbitals can be read by passing the
READVIRTUAL keyword to LOAD. This keyword only makes sense in formats
that contain virtual orbital information (fchk and molden).

#### Making copies of a field

The LOAD COPY keyword can be used to make a copy of the field id.s to
the next available slot, or to id2.s if it is given with the keyword
TO.

#### Loading the promolecular density

The keyword PROMOLECULAR is used to load a promolecular density field
(same as the one in slot 0). If a finite fragment of the crystal is
passed to LOAD PROMOLECULAR as an xyz file (file.xyz) using the
optional FRAGMENT keyword, then the sum of atomic densities is built
using only the atoms in that fragment.

### Additional LOAD options

The definition of a field can be supplemented by additional optional
keywords that depend on the type of field in the input and that come
after the file name. They are:
~~~
NEAREST|TRILINEAR|TRISPLINE|TRICUBIC
~~~
Choose the grid interpolation mode in a grid field. NEAREST, use the
field at the nearest grid point (zero first and second
derivatives). TRILINEAR, trilinear interpolation (zero second
derivatives). TRISPLINE, 3d-spline interpolation (adapted from the
abinit code, this part was coded by A. Lherbier according to the
source). If some derivatives are not available (first and second in
NEAREST, second in TRISPLINE), they are taken as zero. TRICUBIC,
tricubic interpolation using local information, see Lekien and
Marsden, Int. J. Numer. Meth. Engng, 63 (2005) 455-471. 

By default, TRICUBIC is used. TRISPLINE may require a lot of memory in
very large cube files (say, 400^3). However, the memory allocation for
the TRISPLINE interpolation only happens if the parts of critic2 that
require derivatives or interpolation at points outside of the grid are
called. If only grid-based algorithms (e.g. YT, BADER, NCIPLOT with
default NSTEP,...) then no additional memory is used.

Applies to: grids. Default: TRICUBIC.
~~~
CORE|NOCORE
~~~
The electron density from a pseudopotential/plane-waves calculation,
given on a grid, only represents valence electrons. In order to get an
approximation to the all-electron density, it can be augmented by
summing the corresponding core contributions to the electron density
at the atomic sites. The ZPSP values are used to determine how many
electrons are added by each core. The CORE keyword activates this
behavior (i.e., critic2 will use only the valence density from the
external grid file).

Applies to: grids (it can be activated for any other field using CORE,
but that would not make much sense). Default: NOCORE. Note that for
most grid fields read with LOAD, the pseudopotential charges (ZPSP)
are not set, so even if CORE is active, critic2 does not know how many
core electrons to add. ZPSP values are also required for core
augmentation.
~~~
EXACT|APPROXIMATE
~~~
The calculation of the electron density in aiPI and DFTB+ fields is
relatively expensive. Using the APPROXIMATE keyword, the atomic
contributions to the density are calculated by interpolating from a
radial grid, that is precomputed at the beginning of the run. EXACT
calculates the fully analytical values of the field with no
approximations.

Applies to: PI and DFTB+ fields. Default: APPROXIMATE.
~~~
RHONORM|VNORM
~~~
In WIEN2k, the clmsum and other files representing the electron
density have different normalization. The l=0 m=0 radial component is
divided by sqrt(4*pi). The option VNORM can be used if the file in the
input does not present this normalization (e.g. a potential file).

Applies to: WIEN2k. Default: RHONORM.
~~~
NOTESTMT
~~~
FPLAPW (WIEN2k and elk) scalar fields are checked by default for
discontinuities on the muffin tin surface, which can affect (or even
preclude) the location of critical points and the tracing of gradient
paths. This test may take some time if the number of atoms in the
system is large. NOTESTMT skips the discontinuity test.
~~~
NUMERICAL
~~~
Calculate the derivatives of the field numerically. Mostly used for
testing the implementation of new field types.

Applies to: all. Default: no.
~~~
ANALYTICAL
~~~
Calculate the derivatives of the field analytically. Opposite of
NUMERICAL.

Applies to: all. Default: yes.
~~~
TYPNUC {-3,3}
~~~
Controls whether the nuclei are maxima (-3) or minima (3) of the
field.

Applies to: all. Default: -3 (maxima).
~~~
NORMALIZE n.r
~~~
Normalize the grid integral over the unit cell to n.r.

Applies to: grids.
~~~
{NAME|ID} id.s
~~~
Name the field using a string identifier. The identifier can be used
in place of the field number in any expression, including arithmetic
expressions. The label for this field will be echoed in the part of
the output corresponding to this field. The string should be a single
word containing letters and numbers. You can list all available field
identifiers using the LIST keyword, see `Arithmetic expressions,
variables, and functions in critic2`_.
~~~
ZPSP at1.s q1.r...
~~~
Set the pseudopotential charges for this field. Note that setting
these charges does not activate core augmentation (use CORE as
well). See `Atomic charge options` for more details.

### Field arithmetics

New fields can be defined as combinations of the existing ones using
the LOAD AS keyword. This allows the creation of fields that are not
directly computed by the electronic structure program, and is very
useful in combination with the cube-writing keywords (keyword CUBE in
`Simple graphical representations: points, lines, planes,
grids`_). For instance, if rhoup.cube and rhodn.cube are the spin-up
and spin-down densities, it is possible to get the total density and
the spin density using:
~~~
LOAD rhoup.cube
LOAD rhodn.cube
LOAD AS "$1+$2"
LOAD AS "$1-$2"
~~~
The spin-up density is loaded as field 1, rhodn.cube is field 2, field
3 is defined as the sum of both and field 4 is the spin density, which
can, for instance, be graphically represented or integrated in the
atomic basins to get the atomic magnetic moments (see INTEGRABLE in
`Integration of atomic basins`_).

The list of arithmetic operations that can be performed on fields is
quite large (see `Arithmetic expressions, variables, and functions in
critic2`_). If no additional keywords are present between LOAD AS and
the arithmetic expression (like LAP, GRAD, or CLM, see below), then
two types of fields can be loaded. If the arithmetic expression
involves at least one grid, the resulting field will be a grid with
the same number of points. If more than one grid appears in the
expression, then the new grid size is the maximum of the number of
points in every dimension. 

If the expression contains no grid fields, then the resulting field is
what critic2 calls a "ghost field". A ghost field is just an
arithmetic expression that is parsed and processed every time the
field is evaluated. The analyitcal derivatives for a ghost field are,
naturally, not available, so the NUMERICAL option is the default for
this kind of field (see `Additional LOAD options`_).

Regardless of the types of fields in the expression passed to LOAD AS,
a grid field can be enforced by explicitly specifying the size of the
grid, either by giving the number of points in each direction (n1.i
n2.i n3.i) or by adopting the size of another grid (SIZEOF, the mold
grid is field id.s). If grid fields appear in the expression but you
want a ghost field, then use the GHOST keyword.

The PROMOLECULAR option to LOAD AS allows the creation of a grid out
of the promolecular density, with number of points n1.i, n2.i, n3.i or
the size of grid field id.s if the SIZEOF keyword is used. Similarly,
CORE creates a grid using only the core densities, as specified by the
ZPSPs of the atoms. If a fragment of the crystal is passed as an xyz
file to any of those keywords (with the optional FRAGMENT keyword),
then only the atoms in the fragment contribute to the sum of atomic
(or core) densities. 

The LAP, GRAD, POT, and CLM keywords of LOAD AS apply only to specific
types of fields:

* GRAD and POT only apply to grid fields. GRAD defines a new grid as
  the norm of the gradient of the grid field id.s. POT is the
  electrostatic (Hartree) potential generated by the density in field
  id.s. Both are calculated using a Fourier transforms to transform to
  and from reciprocal space. In the case of POT, the resulting
  potential is in Hartree by default (i.e. with a 4*pi pre-factor in
  Poisson's equation). The units can be changed to Rydberg (8*pi
  factor) by using the RY or RYDBERG keyword.

* LAP applies to grid, WIEN2K, and elk fields. In all cases, the
  keyword creates a field of the same type containing the Laplacian of
  the field id.s. If id.s is a grid, the Laplacian is calculated by
  Fourier transform. If it is a WIEN2k or elk field, the Laplacian is
  calculated analytically both inside the muffin tins and in the
  interstitial using the appropriate transformation.

* CLM defines a new field as the addition (id1+id2) or substraction
  (id1-id2) of fields of the WIEN2K or elk type by using the ADD and
  SUB keywords respectively. Note that the muffin tin radii, number of
  plane-waves, etc. have to be the same for both source fields.

### Changing the field options after LOAD (SETFIELD)

The options of a given field can be changed anywhere in the input
after it has been loaded using the SETFIELD keyword:
~~~
SETFIELD {id.s} [NEAREST|TRILINEAR|TRISPLINE|TRICUBIC] 
   [EXACT|APPROXIMATE] [RHONORM|VNORM] [CORE|NOCORE] 
   [NUMERICAL|ANALYTICAL] [TYPNUC {-3,-1,1,3}] 
   [NORMALIZE n.r] [ZPSP at1.s q1.r...]
~~~
SETFIELD changes the properties of field with identifier id.s. The
keywords have the same meaning as in the previous sections.

### Unloading a field (UNLOAD)

~~~
UNLOAD {id.s|ALL}
~~~
Unload the field id.s or all fields (keyword ALL).

### The reference field (REFERENCE)

One of the loaded fields is chosen as the reference field. The
reference field is used as the primary field in all computations. For
instance, when BASINPLOT is used, the basins of the reference field
are plotted. If one uses an integration method (INTEGRALS, QTREE, YT,
BADER), the reference field provides the attraction basins in which
other scalar fields are integrated. If AUTO is used, the critical
points of the reference field are found. And so on.

The first field loaded becomes the reference field. If no fields have
been loaded, then the reference is the promolecular density (field "0"
or "rho0"). In order to change the reference field, the REFERENCE
keyword can be used:
~~~
REFERENCE id.s
~~~
Sets field id.s as reference. The output of this keyword is shown in
section `Typical output for the REFERENCE keyword`_.

### Typical output for the LOAD keyword

The output when loading a field is composed of two parts: a first
block containing information particular to the type of field loaded,
and a second block containing the field flags.

For instance, loading a cube file (or, actually, any grid) gives an
output whose first block looks like this:
~~~
* LOAD scalar field in slot number: 1
* GRID input, from a CUBE file
  In file: rho.cube
  Grid dimensions : 30  30  81
  First elements... 5.8881e-03 6.1552e-03 6.9787e-03
  Last elements... 8.4025e-03 6.9512e-03 6.1350e-03
  Sum of elements... 4.941377690900E+03
  Sum of squares of elements... 7.857493686793E+02
  GRID input successful 
~~~
The output for the other grid file formats (abinit DEN, VASP, qub,
xcrysden's xsf, grid, SIESTA) is essentially the same.  This output
gives the slot number for the loaded field, the type of file format
and the name of the external file containing the field, and the grid
dimension. Next, critic2 gives the first three and last three elements
in the grid (this is mostly for debug purposes).

The last two entries ("Sum of elements" and "Sum of squares of
elements") give the sum of the field and the square of the field over
all the grid nodes. The "Sum of elements" is particularly important
because, in a crystal, it is related to the integral of the field over
the entire unit cell. This integral is given by the "Sum of elements"
times the volume (in bohr^3) divided by the number of grid nodes. 
The example above, for instance, corresponds to a graphite crystal,
with a volume of 236.04767 bohr^3 and 30x30x81 = 72900 grid
points. This gives an integral over the cell of almost exactly 16
electrons. 

The second block for a grid field looks like this:
~~~
+ Flags for field number: 1
  Name: <field_1>
  From: rho.cube
  Type: grid
  Grid dimensions: 30  30  81
  Interpolation mode (1=nearest,2=linear,3=spline,4=tricubic): 3
  Cell integral (grid SUM) (1) = 16.00000922
  Min: 3.40540000E-03
  Average: 6.77829587E-02
  Max: 3.25190000E-01
  Use core densities? T
  Numerical derivatives? F
  Nuclear CP signature: -3
~~~
This block gives the name of the field (used as identifier in the rest
of the output), the source file, the type of field (grid in this
case). Since this is a grid field, the grid dimensions are repeated,
and the type of interpolation used to calculate the field values at
arbitrary points is given. Then, several computed values are given:
the integral of the field over the entire unit cell (related to the
"Sum of elements" above), and the minimum, average, and maximum field
values. This field uses core augmentation (although it is only
actually used if ZPSP are given in the input as well), the calculated
derivatives of the field are analytical, and critical points at the
nuclei are maxima (signature -3).

For WIEN2k and elk fields, the output is similar to:
~~~
* LOAD scalar field in slot number: 1
* WIEN2k input, from a CLMSUM file
  In file: bp.clmsum
  Struct file: bp.struct
  Complex?: T
  Spherical harmonics expansion LMmax: 6
  Max. points in radial grid: 781
  PW cutoff: 1.00000E-30
  Total number of plane waves: 278
  Removed trailing plane-waves: 1912
  New/original number of plane-wave set : 2733/4645

+ Flags for field number: 1
  Name: <field_1>
  From: bp.clmsum
  Type: wien2k
  Density-style normalization? T
  Use core densities? F
  Numerical derivatives? F
  Nuclear CP signature: -3

* Muffin-tin discontinuity test
  Atom: 1 RMS/max/min(fout-fin) = 0.000393 0.000757 -0.000874
  Atom: 2 RMS/max/min(fout-fin) = 0.000972 0.002234 -0.002216
+ Assert - no spurious CPs on the muffin tin surface: T
~~~
The first block gives the source field and structure files, whether
the field contains complex coefficients in the expansions (it does if
the crystal structure is not centrosymmetric), the maximum L for the
spherical harmonics expansion inside the muffins, the number of radial
points inside the muffins, the cutoff for discarding negligible
plane-wave contributions in the interstitial, and the number of
plane-waves remaining after pruning.

The second block gives the normalization of the l=0 m=0 component in
the muffins (see RHONORM and VNORM in `Additional LOAD options`_). 

WIEN2k and elk fields are particular in that they are discontinuous
when the atomic spherical harmonics expansion matches the interstitial
plane-wave expansion on the muffin tin surface. Experience has shown
that, as long as no spurious critical points are generated by this
mismatch, the field will pose no problems to the critical point search
and the gradient path tracing. For small crystals, this is usually the
case, but large molecular crystals may be more tricky. The last block
in the output above shows an automated check for spurious critical
points on the muffin surfaces. In this example, no CPs were found
(last "Assert"). The muffin tin discontiuity test can be
computationally expensive (minutes) if the system contains many
non-equivalent atoms. The NOTESTMT keyword allows skipping the test.

The output for molecular wavefunctions is comparatively simpler:
~~~
* LOAD scalar field in slot number: 1
+ Flags for field number: 1
  Name: <field_1>
  From: benzene.wfn
  Type: molecular wavefunction
  Use core densities? F
  Numerical derivatives? F
  Nuclear CP signature: -3
~~~
It contains only the type of field, the source file, and the three
relevant flags (no core augmentation, analytical derivatives, nuclei
are maxima).

If the LOAD keyword is the first in the run, the field becomes
reference, so the output for the REFERENCE keyword follows. See
`Typical output for the REFERENCE keyword`_.

### Typical output for the REFERENCE keyword

The output of the REFERENCE keyword is simple. First, the field set as
reference is given:
~~~
* Field number 2 is now REFERENCE.
~~~ 
and then the list of the integrable properties. These are the
quantities that will be integrated by the basin integration
methods. Chaning the reference field resets the integrable properties
list to its default value. Namely, the default is to integrate the
basin volumes, the reference field, and the Laplacian of the reference
field. If the reference field is an electron density, then the last
two correspond to the atomic electron population (i.e. the atomic
charges) and the electron density Laplacian. An example of this output
is:
~~~
* List of integrable properties
#  Id  Type  Field  Name
    1   v        0  Volume
    2  fval      2  Charge
    3  lval      2  Lap
~~~
See the `List of properties integrated in the attractor basins
(INTEGRABLE)`_ section for more information on integrable properties
list.

## Usual CRYSTAL/LOAD and MOLECULE/LOAD combinations

* **WIEN2k**

~~~
CRYSTAL name.struct
LOAD name.clmsum name.struct
~~~

* **Quantum ESPRESSO**

~~~
CRYSTAL name.cube
LOAD name.cube

CRYSTAL name.scf.out
LOAD name.cube

CRYSTAL
  CARTESIAN celldm(1)
    ... CELL_PARAMETERS matrix ...
  ENDCARTESIAN
  NEQ x0 y0 z0 C 
  ... rest of the ATOMIC_POSITIONS list ...
ENDCRYSTAL
LOAD name.cube

CRYSTAL name.scf.in
LOAD name.cube
~~~

* **Abinit**

~~~
CRYSTAL name_DEN
LOAD name_DEN
~~~

* **VASP CHGCAR format (divided by cell volume)**

~~~
CRYSTAL POSCAR POTCAR
LOAD CHGCAR ZPSP C 4 H 4

CRYSTAL POSCAR POTCAR
LOAD AECCAR0
LOAD AECCAR2
LOAD AS "$1+$2"
REFERENCE 3

CRYSTAL POSCAR POTCAR
LOAD CHG
LOAD ELFCAR
~~~

* **elk**

~~~
CRYSTAL GEOMETRY.OUT
LOAD STATE.OUT GEOMETRY.OUT
~~~

* **aiPI**

~~~
CRYSTAL
  CELL a b c alpha beta gamma
  SPG 'space group'
  NEQ x y z atom
  ...
ENDCRYSTAL
LOAD at1.ion at1 at2.ion at2 ...
~~~

* **DFTB+ crystal**

~~~
CRYSTAL crystal.gen
LOAD detailed.xml eigenvec.bin wfc.hsd
~~~

* **DFTB+ molecule**

~~~
MOLECULE mol.gen
LOAD detailed.xml eigenvec.bin wfc.hsd
~~~

* **Any code that writes Gaussian cubes**

~~~
CRYSTAL name.cube
LOAD name.cube
~~~

* **Gaussian molecules**

~~~
MOLECULE name.wfn
LOAD name.wfn

MOLECULE name.wfx
LOAD name.wfx

MOLECULE name.fchk
LOAD name.fchk
~~~

* **MOLDEN-style files**

~~~
MOLECULE name.molden
LOAD name.molden
~~~

* **Promolecular/procrystal density calculations**

~~~
CRYSTAL name.cif

MOLECULE name.xyz
~~~

* **Conversion between crystal formats**

~~~
CRYSTAL name.cif
WRITE name.scf.in
WRITE name.xyz MOLMOTIF
~~~

* **Conversion between grid formats**

~~~
CRYSTAL name.cif
LOAD rhoup_DEN
LOAD rhodn_DEN
LOAD AS '$1-$2' n1 n2 n3
CUBE GRID FILE rhospin.cube FIELD 3
~~~

## Simple graphical representations: points, lines, planes, grids

### Points (POINT)

~~~
POINT x.r y.r z.r [ALL] [FIELD {id.s|"expr.s"}]
~~~
Calculates the value of the reference field, its derivatives, and
related quantities at the point (x.r, y.r, z.r) in crystallographic
coordinates (if the structure is a CRYSTAL) or molecular Cartesian
coordinates (if it is a MOLECULE). For the latter, the default units
are angstrom unless changed by the UNITS keyword. If ALL is used, all
loaded fields are evaluated. In addition, all arithmetic expressions
that have been registered using the POINTPROP keyword are also
calculated (see `List of properties calculated at points
(POINTPROP)`_). The POINTPROP keyword combined with POINT is useful to
evaluate chemical functions at arbitrary points in space.

If FIELD is used and followed by an integer or field identifier
(id.s), then only that field is evaluated. FIELD followed by an
arithmetic expression calculates the value of that expression at the
point.

### Lines (LINE)

~~~
LINE x0.r y0.r z0.r x1.r y1.r z1.r npts.i [FILE file.s]
     [FIELD id.s|"expr.s"] [GX|GY|GZ|GMOD|HXX|HXY|HXZ|HYX|HYY|
     HYZ|HZX|HZY|HZZ|LAP]
~~~
Calculate a line from (x0.r y0.r z0.r) to (x1.r y1.r z1.r) with npts.i
points. The units for the two endpoints (x0 and x1) are
crystallographic coordinates in crystals and molecular Cartesian
coordinates in molecules. The latter are angstrom by default (unless
UNITS is used).

By default, the result is written to the standard output, but it can
be redirected to a file using FILE. The reference field is used unless
a FIELD keyword appears, in which case the field id.s or the
expression expr.s are evaluated. Together with the value of the field,
an additional quantity can be evaluated: the components of the
gradient (GX,GY,GZ), the norm of the gradient (GMOD), the components
of the Hessian (HXX,...) and the Laplacian of the reference (or the
id.i) field.

### Planes and contour plots (PLANE)

~~~
PLANE x0.r y0.r z0.r x1.r y1.r z1.r x2.r y2.r z2.r nx.i ny.i 
      [SCALE sx.r sy.r] [EXTENDX zx0.r zx1.r] [EXTENDY zy0.r zy1.r]
      [FILE file.s] [FIELD id.s/"expr"]
      [F,GX,GY,GZ,GMOD,HXX,HXY,HXZ,HYY,HYZ,HZZ,LAP] 
      [CONTOUR {LOG niso.i [zmin.r zmax.r]|ATAN niso.i [zmin.r zmax.r]|
      BADER|LIN niso.i [rini.r rend.r]|i1.r i2.r ...}] [COLORMAP [LOG|ATAN]] 
      [RELIEF zmin.r zmax.r] [LABELZ labelz.r]
~~~
Calculate the value or other properties of the reference field on a
plane. The results are written to a file, with default name
`<root>_plane.dat`. The geometry of the plane is specified by three
points: (x0.r y0.r z0.r) is the origin, (x1.r y1.r z1.r) is the x-end
of the plane and (x2.r y2.r z2.r) is the y-end. The number of
calculated points on each axis are given by nx.i (x-axis) and ny.i
(y-axis). The units for these points are crystallographic coordinates
in a crystal, and molecular Cartesian coordinates in a molecule
(default: angstrom unless the UNITS keyword is used). The two axes of
the plane can be scaled using the SCALE keyword. If sx.r (sy.r) is
given, the total length of the x-axis (y-axis) is scaled by sx.r
(sy.r). If EXTENDX is used, extend the x-axis by zx0.r (initial point
of the x-axis) and zx1.r (end point). The keyword EXTENDY performs the
equivalent operation on the y-axis. The units for EXTENDX and EXTENDY
are bohr (crystals) or angstrom (molecules) unless changed by the
UNITS keyword.

The name of the output file can be changed with FILE. Using FIELD, one
of the loaded fields (id.s) or an expression ("expr.s") can be
evaluated. In addition to the field value, a second property can be
evaluated: the field again (F), its derivatives (Gx), its second
derivatives (Hxx), the gradient norm (GMOD) or the Laplacian (LAP).

The keyword CONTOUR writes a contour map representation of the plane:
two contour line files (.iso and .neg.iso) and a gnuplot script
(.gnu). The isovalue distribution can be: logarithmic (LOG, with
niso.i contours), arctangent (ATAN, with niso.i contours), same as in
the aimpac program (BADER, {1,2,4,8}x10^{-3,-2,-1,0,1}), linear (LIN,
niso.i contours from r0.r to r1.r), or the user can specify the
contour values manually (no keyword). In LOG and ATAN, the default
contours range from the minimum to the maximum value of the field in
the plot. These quantities can be changed by passing the optional
zmin.r and zmax.r parameters to LOG/ATAN. The field or any of its
derivatives, selected with the [F|GX|...] keyword, is used for the
contour plot.  The GRDVEC keyword (see `Gradient path representations
in a plane (GRDVEC)`_) performs the same functions as PLANE with the
CONTOUR option, and more (like, for instance, tracing gradient paths
in the plane), but is more complex to use.

The RELIEF keyword writes a gnuplot template for a three-dimensional
relief plot using the data calculated by PLANE. The default suffix is
-relief.gnu. The mandatory arguments zmin.r and zmax.r establish the
range of the z axis in the plot. 

The COLORMAP keyword writes a template for a colormap plot of the
field on the plane. If the LOG or ATAN keywords are given, the
logarithm or the arctangent of the field are represented in the
colormap.

For the plots that display atomic or critical point labels, LABELZ
controls how many labels are represented. Any atom or critical point
that is at a distance less than labelz.r (default: 0.1 bohr) is shown
as a label in the plot.

### Grids (CUBE)

~~~
CUBE x0.r y0.r z0.r x1.r y1.r z1.r nx.i ny.i nz.i [FILE file.s] [FIELD id.s/"expr"]
     [F,GX,GY,GZ,GMOD,HXX,HXY,HXZ,HYY,HYZ,HZZ,LAP] [HEADER]
CUBE x0.r y0.r z0.r x1.r y1.r z1.r bpp.r ...
CUBE CELL {bpp.r|nx.i ny.i nz.i} ...
CUBE GRID ...
CUBE ... FILE CHGCAR
CUBE ... FILE bleh.cube
CUBE ... FILE bleh.bincube
~~~
The CUBE keyword writes a three-dimensional grid in Gaussian cube,
binary cube, or VASP CHGCAR formats. The limits of the grid can be set
in three ways. By giving the end-points (x0.r y0.r z0.r) and (x1.r
y1.r z1.r) it is possible to build a grid from an orthogonal fragment
of space. The CELL keyword calculates a grid spanning the entire unit
cell, which may or may not be orthogonal depending on the
structure. GRID has the same effect as CELL regarding the output grid
geometry. If the end points are given, they should be in
crystallographic coordinates in crystals (the structure was read using
the CRYSTAL keyword) or molecular Cartesian coordinates
(MOLECULE). The units in the latter default to angstrom unless changed
using the UNITS keyword.

The number of points in the grid can also be controlled in several
ways. If the cube limits are given explicitly or using CELL, then the
number of points in each axis can be indicated by giving three
integers (nx.i, ny.i, and nz.i) corresponding to the number of points
in the x-, y-, and z-axis respectively. If a single number (bpp.r) is
found, then the number of points is the length of the axis divided by
bpp.r (that is, bpp is the number of bohrs per point, hence the
name). The GRID keyword can be used to write a field defined on a grid
directly to a cube file. This is useful when combined with the LOAD
keyword to read, manipulate, and then save grids to an external
file. If GRID is used, both the geometry of the grid and the number of
points are adopted from the corresponding field.

Independently on how the grid is set up, several options control the
behavior of CUBE. FILE sets the name of the output file (default:
CHGCAR). If the extension of file.s is not .cube, then critic2 uses
the vasp-style CHGCAR format for the output. HEADER writes only the
header to the output file (no calculations are done). FIELD sets the
field to be used by numer or identifier label (id.s). Alternatively,
an arithmetic expression that combines the existing fields can be
used. Finally, a derivative of the scalar field (gradient, Hessian,
Laplacian) can be selected instead of the value of the field itself
(F) to build the grid.

## Finding critical points

### Automatic determination of critical points (AUTO)

~~~
AUTO [GRADEPS eps.r] [CPEPS eps.r] [NUCEPS neps.r] [NUCEPSH nepsh.r]
     [EPSDEGEN edeg.r] [DISCARD expr.s] [CHK] [DRY] [SEEDOBJ] ...
AUTO ... [CLIP CUBE x0.r y0.r z0.r x1.r y1.r z1.r]
AUTO ... [CLIP SPHERE x0.r y0.r z0.r rad.r]
AUTO ... [SEED ...] [SEED ...] ...
AUTO SEED WS [DEPTH depth.i] [X0 x0.r y0.r z0.r]
             [RADIUS rad.r]
AUTO SEED OH [DEPTH depth.i]  [X0 x0.r y0.r z0.r]
             [RADIUS rad.r] [NR nr.r]
AUTO SEED SPHERE [X0 x0.r y0.r z0.r] [RADIUS rad.r]
                 [NTHETA ntheta.i] [NPHI nphi.i] [NR nr.r]
AUTO SEED PAIR [DIST dist.r] [NPTS n.i]
AUTO SEED TRIPLET [DIST dist.r]
AUTO SEED LINE [X0 x0.r y0.r z0.r] [X1 x0.r y0.r z0.r]
               [NPTS n.i]
AUTO SEED POINT [X0 x0.r y0.r z0.r]
AUTO SEED MESH
~~~
The search for the critical points (CP) of a scalar field (the points
where the gradient of the field vanishes) is a basic task in QTAIM. In
critic2, this search is almost always conducted using the automatic CP
localization algorithm via the AUTO keyword.

The automatic search for critical points has two steps: seeding and
searching. In the seeding step, a collection of points are selected in
the unit cell that span the crystal or molecular space where CPs are
likely to appear. In the search step, a Newton-Raphson algorithm is
launched at each of the seeds in order to find nearby critical
points.

The default seeding behavior in critic2 depends on whether the
geometry under study is a crystal (loaded with the CRYSTAL keyword) or
a molecule (MOLECULE keyword):

* In a crystal, AUTO calculates the Wigner-Seitz (WS) cell and its
  irreducible part (the smallest piece that reproduces the WS cell by
  symmetry). Once the irreducible WS (IWS) cell is found, seed points
  are chosen by subdividing the edges, faces and interior of the
  tetrahedra that the IWS comprises up to a certain subdivision level
  (the DEPTH).

* In a molecule, a single seed is planted at the midpoint between
  every atom pair less than 15 bohr apart.

In addition, AUTO provides multiple seeding strategies that can be
combined by the user using the SEED keyword. These include searches
between pairs of atoms (PAIR), atomic triplets (TRIPLET), uniform
seeding in a sphere (SPHERE), a recursive subdivision of an octahedron
(OH), seeding along lines (LINE) and at points (POINT), and seeding at
a molecular integration mesh (MESH). The seed list built using these
"seeding actions" is pruned to remove duplicates. Optionally, a
portion of the unit cell can be selected to restrict the search in
real space using the CLIP keyword. Once the seed list is built,
Newton-Raphson is applied at each of the seeds on the list, making
full use of shared-memory parallelization and crystal symmetry.

The default seeding can be changed using one or more SEED
keywords. When a SEED keyword is used, the default seeding strategy is
forgotten by critic2 and manual control of the seeding is used
instead. Several SEED keywords can be used at the same time, each one
specifying a single "seeding action" that is determined by the keyword
immediately after SEED. This keyword can be:

* WS: a recursive subdivision of the Wigner-Seitz cell to level
  depth.i (keyword: DEPTH, default: 1). The WS cell can be displaced
  and centered somewhere in the unit cell using X0 (default: (0,0,0))
  and scaled down to a radius of rad.r (keyword: RADIUS, default: not
  used). The units for x0 are crystallographic coordinates in crystals
  and molecular Cartesian coordinates in molecules (default: angstrom
  unless changed by UNITS). For rad.r, the default units are bohr in
  crystals and angstrom in molecules.

* OH: a sphere of radius rad.r (keyword RADIUS, mandatory) is built
  around (x0.r y0.r z0.r) (keyword X0, mandatory). On the surface of
  that sphere, points are set according to a recursive subdivision
  algorithm that starts from a single octahedron and uses depth.r
  recursion levels (keyword: DEPTH, default: 1). This is the same
  procedure as the TRIANG keyword in BASINPLOT. Each resulting point
  on the sphere surface determines a single ray along which nr.r seeds
  are uniformly distributed (keyword: NR, mandatory), from X0 to the
  surface of the sphere. The units for x0 are crystallographic
  coordinates in crystals and molecular Cartesian coordinates in
  molecules (default: angstrom unless changed by UNITS). For rad.r,
  the default units are bohr in crystals and angstrom in molecules.

* SPHERE: a sphere of radius rad.r (keyword RADIUS, mandatory) is
  built around (x0.r y0.r z0.r) (keyword X0, mandatory). On the
  surface of that sphere, points are uniformly distributed, with a
  placement algorithm that uses nphi.i points in the azimuthal angle
  (keyword: NPHI, mandatory) and ntheta.i points in the polar angle
  (keyword: NTHETA, mandatory). Each resulting point on the sphere
  surface determines a single ray along which nr.r seeds are uniformly
  distributed (keyword: NR, mandatory), from X0 to the surface of the
  sphere. The units for x0 are crystallographic coordinates in
  crystals and molecular Cartesian coordinates in molecules (default:
  angstrom unless changed by UNITS). For rad.r, the default units are
  bohr in crystals and angstrom in molecules.

* PAIR: seeds are placed on the interatomic lines, for all atom pairs
  at a distance less than dist.r (keyword: DIST, default: 15). The
  number of seeds per line is n.i (keyword: NPTS, default: 1). The
  default units for dist.r are bohr in crystals, angstrom in
  molecules. 

* TRIPLET: seeds are placed at the barycenter of every atomic triplet
  in which the three atoms are at a distance from each other less than
  dist.r (keyword: DIST, default: 15). The default units for dist.r
  are bohr in crystals, angstrom in molecules. 

* LINE: place n.i seeds (keyword: NPTS, default: 1) along a line
  between (x0.r y0.r z0.r) (keyword: X0, default: origin) and (x1.r
  y1.r z1.r) (keyword: X1, mandatory). The units for x0 and x1 are
  crystallographic coordinates in crystals and molecular Cartesian
  coordinates in molecules (default: angstrom unless changed by
  UNITS).

* POINT: place a single seed at (x0.r y0.r z0.r) (keyword: X0,
  mandatory). The units for x0 are crystallographic coordinates in
  crystals and molecular Cartesian coordinates in molecules (default:
  angstrom unless changed by UNITS).

* MESH: place seeds at the nodes of a molecular integration mesh. The
  type of mesh can be controlled with the MESHTYP keyword (see
  `Control commands and options`_).

Multiple SEED keywords can be given in the same AUTO command. For
instance:
~~~
AUTO SEED PAIR SEED WS SEED POINT 1/4 1/4 1/4
~~~
executes three seeding actions: a search between all atoms pairs (1
seed per pair), a recursive subdivision of the WS cell (one level),
and a single seed at (0.25 0.25 0.25). The seed placement can be
visualized using the optional SEEDOBJ keyword that writes an OBJ file
(<root>_seeds.obj) containing the unit cell and all the seed
positions.

The AUTO search can be restricted to a portion of the unit cell using
the CLIP keyword. The CLIP keyword specifies a region of real
space. Only the seeds inside that region are used, and only the CPs
found inside that region are accepted (although, in crystals, symmetry
can replicate the CPs and send them outside the CLIP region; use
CLEARSYM or NOSYMM to deactivate symmetry if necessary, see `Symmetry
options`_). There are two possible region shapes in CLIP: a
parallelepiped (CUBE) and a sphere (SPHERE). The parallelepiped is
specified by giving its initial (x0) and final (x1) points. The sphere
requires a center (x0) and a radius. The units for x0 and x1 are
crystallographic coordinates in crystals and molecular Cartesian
coordinates in molecules (default: angstrom unless changed by
UNITS). For rad.r, the default units are bohr in crystals and angstrom
in molecules.

A number of additional optional keywords control the behavior of
AUTO. GRADEPS is the gradient norm threshold for the optimization: if
a CP is found with gradient norm less than GRADEPS (default: 1e-12),
then it is accepted as CP.

The DISCARD keyword can be used to reduce the list of critical
points. If the expression expr.s evaluated at the critical point is
non-zero, the critical point is discarded. A typical use for this
keyword is when the system has a vacuum region. The (spurious)
critical points in the vacuum region can be eliminated from the list
by doing, for instance, DISCARD "$rho < 1e-7" to remove the critical
points with density lower than 1e-7. The arithmetic expression can
involve any number of fields, not just the reference field.

If DRY (dry run) is used, then the seeding is done but the actual CP
search is skipped. This is useful to examine the seed placement (in
combination with SEEDOBJ) and also to print the current list of CPs at
zero computational cost (for intsance, after a CHECK run).

CPEPS controls the minimum distance between CPs to consider them
equivalent. The default units for CPEPS are bohr in crystals and
angstrom in molecules. Default: 0.2 bohr. Similarly, NUCEPS controls
the distance to consider a CP the same as a nucleus. If a CP is found
at a distance less than neps.r from the closest nucleus, critic2
considers the two are the same. The default value of NUCEPS is 0.1
bohr, except for fields defined on a grid, where it defaults to 2
times the maximum of the grid step in each direction. Hydrogens are
particular in that the maximum of the electron density may be
significantly displaced from the atomic position. A separate NUCEPS
distance criterion is provided for hydrogens (NUCEPSH), which defaults
to 0.2 bohr.

EPSDEGEN controls how degenerate critical points (i.e. one or more
eigenvalues of the Hessian is zero) are discarded. This is important
to get rid of critical points that appear in vacuum regions. A
critical point is considered degenerate if any of the elements of the
diagonal of the Hessian is less than edeg.r in absolute value.

Because finding the CPs can be an expensive task in large structures,
the CP list for the current field can be saved to a checkpoint file
using the CHK keyword. This keyword generates a <root>.chk_cps file
where the list of critical points is stored. It can be accessed in
subsequent critic2 runs by using the CHK keyword in AUTO. For
instance, to read the CPs from the checkpoint file and skip any
calculation in AUTO, you can do:
~~~
AUTO DRY CHK
~~~
By default, checkpoint files are not used.

#### Example output for AUTO in a crystal

In crystals, critic2 writes all the critical points found by AUTO to
two internal lists: the "non-equivalent" list, containing only those
CPs not equivalent by symmetry, and the "complete" list, which
contains all the CPs in the unit cell (see `Input format, output
format, and notation`_). In molecules, symmetry is not used, so both
lists are the same.

The most important part of the AUTO output is the "final report",
which gives the non-equivalent CP list and some other useful
information. Its appearance is (the table has been simplified to fit
the width of the page):
~~~
* Critical point list, final report (non-equivalent cps)
  Topological class (n|b|r|c):   2(8) 1(16) 1(16) 2( 8)
  Morse sum :   0
# ncp pg type    position  mult name  f     |grad|     lap
1 Td  (3,-3) n 0.00 0.00 0.00  4 B  7.19E+1 0.00E+00 -3.00E+15
2 Td  (3,-3) n 0.25 0.25 0.25  4 P  2.36E+3 0.00E+00 -3.00E+15
3 C3v (3,-1) b 0.09 0.59 0.59 16 b1 1.25E-1 4.43E-17 -2.25E-01
4 C3v (3, 1) r 0.88 0.88 0.61 16 r1 1.08E-2 1.09E-16  3.45E-02
5 Td  (3, 3) c 0.75 0.75 0.75  4 c1 5.63E-3 1.34E-16  2.22E-02
6 Td  (3, 3) c 1.00 0.00 0.50  4 c2 7.28E-3 1.32E-16  2.58E-02
~~~
The non-equivalent CP list gives the type and position of all the
non-equivalent CPs found, their associated name, rank and signature,
and multiplicity. Critic2 also provides the site-symmetry (pg), and
the values of the reference field (f), its gradient (grad) and its
Laplacian (lap) evaluated at the CPs. The 'topological class' gives
the number of non-equivalent ncp, bcp, rcp, and ccp found. The values
in parentheses correspond to the total number of CPs of each class in
the cell. If the list is complete, then the Morse sum is zero (in a
crystal) or one (in a molecule). 

Following the final report is the "analysis of system bonds" and
"analysis of system rings":
~~~
* Analysis of system bonds
# ncp end1 end2 r1(bohr) r2(bohr) r1/r2  r1-B-r2(degree)
  3    Mg    O   1.7789   2.1999 0.80864  179.9999  

* Analysis of system rings
# ncp end1 end2 r1(bohr) r2(bohr) r1/r2  r1-R-r2(degree)
  4    c01  c01  1.9894   1.9894 1.00000  179.9999
~~~
These contain a list of all the bond (resp. ring) critical points
found and the corresponding nuclei (resp. cages) they connect. The
connected nuclei are found by tracing an upwards gradient path from
the bonds. The cages are found using a downwards gradient path from
the ring. In addition, it is also shown the geometric distance to the
connected critical point, the ratio between the distances, and the
angle formed by the bond path (ring path) at the bcp (rcp).

The **complete CP list** is the list of all CPs in the unit cell, and
comes next in the output. The identifiers from this list are used as
input for other keywords (for instance, GRDVEC or FLUXPRINT) as they
specify a particular position in the crystal. The entries are similar
to the non-equivalent CP list (the table has been simplified):
~~~
* Complete CP list
  (x symbols are the non-equivalent representative atoms)
  cp ncp typ | x  | y  | z  | op.   (lvec+cvec)
x 1  1  n    1.00 0.50 0.32  1   1.0   0.0   0.0
  2  1  n    0.50 0.00 0.67  2   0.0   0.0   1.0
x 3  2  n    1.00 0.50 0.59  1   1.0   0.0   0.0
  4  2  n    0.50 0.00 0.40  2   0.0   0.0   1.0
[...]
~~~
The columns are, in order, the CP identifier (cp), the identifier for
the same CP in the non-equivalent CP list (ncp), the type of CP, the
position in crystallographic coordinates, and the symmetry operation
that transforms the CP from the non-equivalent CP list into the listed
CP. 'Op.' corresponds to one of the symmetry operations listed in the
output and "lvec+cvec" is a translation. Application of the operation
'op.' to the non-equivalent CP followed by the translation recovers
the position of the CP in the complete list. The CPs that are at
exactly the same position as the corresponding CPs in the
non-equivalent list are listed first and marked with an 'x'. Note that
for these, the operation is always 1 (the identity) and the
translation vector is always a lattice translation.

The complete list is followed by a list of all the bcps and rcps in
the unit cell, together with the particular nuclei linked by the bond
path they represent (bcp) or with the cages linked by the ring path
(rcp):
~~~
* Complete CP list, bcp and rcp connectivity table
# (cp(end)+lvec connected to bcp/rcp)
#cp ncp typ   position    end1 (l) end2 (l)
1    1   n 0.00 0.00 0.00 
[...]
9    3   b 0.50 0.50 0.77 4 (0 0 1) 5 (0 0 0)
10   3   b 0.50 1.00 0.27 3 (0 1 0) 6 (0 1 0)
[...]
33   4   r 0.75 0.25 1.00 63 (0 0 1) 57 (0 0 0)
34   4   r 0.75 0.75 0.50 64 (0 0 0) 58 (0 0 0)
~~~
This list is similar to the complete CP list, but the two entries at
the end (end1 and end2) give the two identifiers from the complete CP
list that the bond or ring is connected to, as well as the lattice
vector by which it should be translated to regenerate their actual
position. 

More information about the atomic connectivity through bcps can be
found in the "attractor connectivity matrix:
~~~
* Attractor connectivity matrix
              n(1)  n(2) 
               Mg    O   
 n(1)    Mg     0     6   
 n(2)    O      6     0   
~~~
This list gives the number of bond paths between the different types
of non-equivalent atoms in the cell. For instance, in the example
above, each Mg (row 1) is bonded to six adjacent oxygens through six
bcps (second entry in the matrix) but there are no Mg-Mg bond
paths. Likewise, every oxygen is bonded to six Mg, but there are no
O-O bond paths.

The final part of the output from AUTO contains a detailed list of all
the non-equivalent critical points found, together with an exahustive
list of properties calculated at those points. More properties can be
calculated by using the POINTPROP keyword (see `List of properties
calculated at points (POINTPROP)`_):
~~~
* Additional properties at the critical points
[...]
+ Critical point no. 4
  Crystallogrpahic coordinates: 0.75 0.25 1.00
  Cartesian coordinates (bohr): 5.96 1.98 7.95
  Type : (3,1)
  Field value (f): 2.350841441E-02
  Field value, valence (fval): 2.350841441E-02
  Gradient (grad f): 3.77e-16 -3.76e-16 2.65e-17
  Gradient norm (|grad f|): 5.340413578E-16
  Laplacian (del2 f): 2.889105008E-02
  Laplacian, valence (del2 fval): 2.889105008E-02
  Hessian eigenvalues: -7.02e-3  3.42e-3  3.24e-2
  Hessian:
     1.795930240E-02   1.453912685E-02  -1.850420411E-19
     1.453912685E-02   1.795930240E-02  -4.127816220E-19
    -1.850420411E-19  -4.127816220E-19  -7.027554725E-03
  Ellipticity (l_1/l_2 - 1): -3.054735092E+00
[...]
+ Flatness (rho_min / rho_b,max): 0.462267
~~~
The list of properties calculated by default contains the
crystallographic and Cartesian coordinates, the rank and signature of
the critical point, the value of the reference field at that point and
its derivatives (gradient, gradient norm, Laplacian, Hessian). The
ellipticity is the quotient between Hessian eigenvalues, only relevant
at bcps or rcps. The final entry, flatness, given at the end of the
list, is the quotient between the density minimum and the maximum
density at the bond critical points.

#### Example output for AUTO in a molecule

The output for AUTO in a molecule is similar to a crystal but simpler,
since there is no distinction between the non-equivalent critical
point list and the complete CP list. The list of CPs is given first,
together with the class, and the Poincare-Hopf sum (which is 1 for a
complete list of CPs):
~~~
* Critical point list, final report (non-equivalent cps)
  Topological class (n|b|r|c): 12(12) 12(12) 1(1) 0(0) 
  Poincare-Hopf sum: 1
# ncp type      position (ang_) name   f    |grad|   lap
  1  (3,-3) n  0.00  1.20  0.69  C  1.1e+2 0.0e+00 -4.3e+5
  [...]
  24 (3,-1) b -0.00  1.81 -1.04 b06 2.7e-1 2.8e-13 -9.6e-1
  25 (3,1 ) r -0.00 -0.00  0.00 r01 2.0e-2 1.0e-15 1.6e-1
~~~
Each row contains the CP identfier, the rank and signature, the type
of critical point, the position in Cartesian coordinates (angstrom
by default), the name, and the value, gradient and Laplacian of the
reference field at that point. The complete CP list is exactly the
same as the above, so it is not repeated.

The CP list is followed by the analysis of the connectivity between
atoms via bonds and between cages via rings:
~~~
* Analysis of system bonds
# ncp end1 end2 r1(ang) r2(ang) r1/r2 r1-B-r2(degree)
 13    C    C   0.6979  0.6979  1.000   179.8198  
 [...]
 24    C    H   0.6959  0.3907  1.781   179.9998  

* Analysis of system rings
# ncp end1 end2 r1(ang) r2(ang) r1/r2 r1-R-r2(degree)
 25    ??  ??   6.7788  6.7788  1.000   180.0000  
~~~
followed by the attractor connectivity matrix:
~~~
* Attractor connectivity matrix
              n(1)  n(2)  n(3)  n(4)  n(5)  n(6) 
               C     H     C     H     C     H   
 n(1)    C      0     1     1     0     0     0   
 [...]
n(12)    H      0     0     0     0     0     0   
              n(7)  n(8)  n(9) n(10) n(11) n(12) 
               C     H     C     H     C     H   
 n(1)    C      0     0     0     0     1     0   
 [...]
n(12)    H      0     0     0     0     1     0   
~~~
These lists have the same meaning as in the crsytal example. Finally,
the output contains the exhaustive list of properties at the critical
points. As in the case of crystals, the list of properties calculated
at the critical points can be varied using the POINTPROP keyword (see
`List of properties calculated at points (POINTPROP)`_):
~~~
* Additional properties at the critical points
[...]
+ Critical point no. 4
  Coordinates (ang_): 0.0000000000 2.1497999997 -1.2411900006
  Type : nucleus
  Field value (f): 4.254133728E-01
  Field value, valence (fval): 4.254133728E-01
  Gradient (grad f): 0.00e+00  0.00e+00  0.00e+00
  Gradient norm (|grad f|): 0.000000000E+00
  Laplacian (del2 f): -1.951050589E+01
  Laplacian, valence (del2 fval): -1.951050589E+01
  Hessian eigenvalues: -6.64e+00  -6.63e+00  -6.22e+00
  Hessian:
    -6.639684283E+00  -4.772491252E-15   2.755444887E-15
    -4.772491252E-15  -6.329875105E+00  -1.827977265E-01
     2.755444887E-15  -1.827977265E-01  -6.540946498E+00
  Field 0 (f,|grad|,lap): 3.16e-01 0.00e+00 -7.26e+00
[...]
~~~
The only difference with the output in a crystal is that the
coordinates are given in Cartesian and referred to the molecular
origin, and the flatness is missing.

#### Problems finding critical points

Sometimes, the zero (one) sum condition for the critical points is not
fulfilled, which is usually caused by (often unavoidable) numerical
shortcomings of the scalar field.

In WIEN2k and elk densities, there might be spurious CPs at the
surface of the muffin tin (where the density is discontinuous) that
show up in the final report list. Every time a FPLAPW field is
loaded, every atomic muffin is checked for discontinuities and the
report printed to the output.

In DFTB+ and other fields missing the core electrons
(e.g. plane-wave calculations), the use of core-augmentation (ZPSP
and CORE keywords) is recommended to prevent the appearance of
spurious critical points close to the nuclei.

In scalar fields with extreme variations in value (e.g. the
Laplacian of the electron density), it is unlikely that AUTO will
find all the core CPs. A previous version of critic2 does that
(available upon request) but since the core CPs are not all that
interesting, we have decided to remove that code from this version.

By far, the most problematic type of field for CP localization is a
grid of values. The difficulty is in finding a way to calculate the
first and second derivatives of the field at arbitrary points in space
(i.e. doing an interpolation) in a way that is both accurate and
smooth. Barring numerical noise from the grid, the TRICUBIC
interpolant (which is the default) is quite adequate. Typically, all
high-density critical points will be found. Critical points close to
degenerate (i.e. that are near to other critical points), may appear
as clusters, which is caused by the oscillations of the field
derivatives in that region. It is strongly advised that the position
of the critical points with respect to the structure is examined
always (a graphical representation can be obtained using the CPREPORT
keyword). A finer grid may help with the CP clustering, but this will
increase the cost of the density calculation.

The region where the value of the field is very small are subject to
the appearance of many spurious critical points, due to the very small
value of the gradient. These regions typically appear in the vacuum
region of a slab, or far away from a molecular system. To eliminate
the critical points in these regions, use the DISCARD keyword combined
with a threshold for the field value. For instance, to discard all
critical points with density less (loaded in field $rho) than 1e-5,
use DISCARD "$rho < 1e-5".

#### Visualization of critical points

Critic2 does not come with a graphical interface to visualize the
results of your calculations (yet). This can be a problem when your
list of critical points is very large, if you want to identify one
particular critical point among many, or if you need to calculate
distances between atoms and/or critical points. However, there are
some molecular visualization programs that can be used to read the
output of critic2, and I will describe in this section the most
comfortable procedure (in my opinion) to do so. If you know a better
way, please let me know.

The key to critical point visualization is the CPREPORT keyword. When
used with one of the available output file formats, critic2 will write
the list of atoms plus the critical points in that format. The
critical points are labeled as "Xn" (nuclear CP), "Xb" (bonds), "Xr"
(rings), and "Xc" (cages). The color scheme for critical points is
dark green (nCP), yellow (bCP), purple (rCP), and light red
(cCP). Gradient paths can also be represented using the GRAPH
keyword. Points along a gradient path use the symbol "Xz" in the
output, and are colored in green.

The list of critical points is written to the output in the same order
as in critic2's complete critical point list, unless one of the
special keywords to modify the plotting region is used
(e.g. MOLMOTIF). This means that, if your graphical program gives you
the atom labels, atom number n in the GUI will correspond exactly to
critical point number n in critic2.

The challenege, therefore, is to make external programs understand
that we have objects (critical points) that should be treated like
atoms, but are not atoms. An easy (and sometimes very convenient) way
of doing this is to replace the critical point labels ("Xb", "Xr",...)
with atoms we know are not present in our system (e.g. H). 

However, a better method is to make the extend the list of atoms
available to the GUI program. This can be done using avogadro, an
open-source visualizer for crystals and molecules that can be obtained
from:
  
   <http://avogadro.cc/wiki/Main_Page>

The following comments apply to version 1.2.0 of the program (August
2016). 

Avogadro uses openbabel (http://openbabel.org/wiki/Main_Page) as the
underlying format converter. To make avogadro understand the critical
point types, all you need to do is modify the element.txt file that
comes with openbabel, and add the critical point types at the end of
the atomic species list:
~~~
[...]
118     Uuh     0.00    1.60    0.00    0.00    6       294     0.00    0       0       0.99    0.00    0.06    Ununoctium
119     Xn      0.00    0.50    0.00    0.50    0       0       0.00    0       0       0.2805  0.6223  0.0164  nCP
120     Xb      0.00    0.50    0.00    0.50    0       0       0.00    0       0       1.0000  0.8512  0.2380  bCP
121     Xr      0.00    0.50    0.00    0.50    0       0       0.00    0       0       0.5851  0.5349  1.0000  rCP
122     Xc      0.00    0.50    0.00    0.50    0       0       0.00    0       0       1.0000  0.3998  0.3411  cCP
123     Xz      0.00    0.20    0.00    0.20    0       0       0.00    0       0       0.1709  1.0000  0.0000  xCP
~~~
With these changes, atoms and critical points will be represented, and
the latter will use the color scheme mentioned above. 

The simplest file formats generated by critic2 and understood by
avogadro are cif files (for crystals), xyz files (for molecules and
finite representations of crystals), and cml files (crystals and
molecules). At the moment, the capabilities of avogadro to handle
periodic systems are limited, but development is currently ongoing. To
access the critical point labels (which correspond to the critic2
lables), go to Display types, mark "Label", click on the Label
options, and select "Text: atom number". The recommended format both
for molecules and crystals is cml, which has several advantages over
xyz and cif: i) it prevents avogadro from calculating the molecular
connectivity, which can be expensive in a very large system, and ii)
it allows showing a fragment of the crystal along with the unit cell.

### Requesting more information about the critical point list (CPREPORT)

~~~
CPREPORT {SHORT|LONG|VERYLONG|SHELLS [n.i]}
CPREPORT file.{xyz,gjf,cml} [SPHERE rad.r [x0.r y0.r z0.r]] 
         [CUBE side.r [x0.r y0.r z0.r]] [BORDER] [ix.i iy.i iz.i]
         [MOLMOTIF] [ONEMOTIF] [ENVIRON dist.r]
         [NMER nmer.i]
CPREPORT file.{obj,ply,off} [SPHERE rad.r [x0.r y0.r z0.r]] 
         [CUBE side.r [x0.r y0.r z0.r]] [BORDER] [ix.i iy.i iz.i] 
         [MOLMOTIF] [ONEMOTIF] [CELL] [MOLCELL] 
CPREPORT file.scf.in
CPREPORT file.tess
CPREPORT file.cri|file.incritic
CPREPORT {[file.]POSCAR|[file.]CONTCAR}
CPREPORT file.abin
CPREPORT file.elk
CPREPORT file.gau
CPREPORT file.cif
CPREPORT file.m
CPREPORT file.gin 
CPREPORT file.lammps
CPREPORT file.fdf
CPREPORT file.STRUCT_IN
CPREPORT file.hsd
CPREPORT file.gen
CPREPORT [...] [GRAPH]
~~~
CPREPORT prints additional information about the critical points to
the output. SHORT: print the list of non-equivalent critical
points. LONG: in a crystal, print the complete list of critical points
in the unit cell and the connectivity in the case of bcp and rcp (when
the graph is calculated); in a molecule, it is the same as
SHORT. VERYLONG: detailed information at every critical point,
including the derivatives of the reference field, the evaluation of
all other fields, and the flatness (in a crystal only). SHELLS: local
neighbor environment of every critical point (up to n.i shells,
default 10). 

In addition, any of the file formats available in the WRITE command
can also be used in CPREPORT to write the molecular or crystal
structure plus the critical point list in the relevant region. The
behavior of these options is analogous to WRITE (except in that the
critical points are written, in addition to the atoms). See `Exporting
the structure (WRITE)`_ for more information. The critical points are
written using special symbols: Xn for a nuclear CP, Xb for a bond, Xr
for a ring, and Xc for cage. Miscellaneous or unassigned critical
points, and points along a gradient path are labeled Xz. Unless
special options are used to change the region being writteh by
CPREPORT (such as MOLMOTIF, BURST, etc.), the atoms and critical
points in the output file are in the same order as in critic2's
complete critical point list.

The optional GRAPH keyword can be used in combination with any of the
file formats mentioned above. When GRAPH is used, the bond paths are
calculated and represented.

### List of properties calculated at points (POINTPROP)

The default output for AUTO contains a list of detailed information
at the critical points. This is an example of what this section looks
like:
~~~
* Additional properties at the critical points
[...]
+ Critical point no. 9
  Crystallogrpahic coordinates: 0.65183 0.90869 0.72597
  Cartesian coordinates: 12.89298 22.10026 33.60159
  Type : (3,-1)
  Field value (f): 4.939109713E-03
  Field value, valence (fval): 4.939109713E-03
  Gradient (grad f): -9.5115E-18 3.8415E-17 4.1112E-18
  Gradient norm (|grad f|): 3.978845324E-17
  Laplacian (del2 f): 1.312332087E-02
  Laplacian, valence (del2 fval): 1.312332087E-02
  Hessian eigenvalues: -2.11139E-03 -1.48096E-03 1.67156E-02
  Hessian:
    -2.068242883E-04  -5.185807347E-03   1.179735612E-03
    -5.185807347E-03   1.373314257E-02  -4.510661176E-03
     1.179735612E-03  -4.510661176E-03  -4.029974096E-04
~~~
For each critical point, the coordinates (Cartesian and
crystallographic in a crysatl), the type, and the evaluation of the
reference field and its derivatives is given. In many cases, it is
interesting to calculate the value of a different field, or even an
arithmetic expression involving other fields, at those critical
points. For instance, it is relatively common to use the kinetic
energy density at the bond critical points of the electron density as
a measure of bond covalency.

To obtain more information at the critical points of the reference
field, the procedure in critic2 is to register a field or an
arithmetic expression involving known fields in the "properties
list", accesible using the POINTPROP keyword:
~~~
POINTPROP name.s "expr.s"
POINTPROP shorthand.s
POINTPROP CLEAR
POINTPROP LIST
~~~
The POINTPROP keyword associates the expression "expr.s" with the name
name.s and register that name in a list of properties. When AUTO is
run (or CPREPORT, if the POINTPROP order comes after AUTO), those
arithmetic expression will be applied to each of the CPs and the
result printed in the output. For instance, if one does:
~~~
POINTPROP MYGTF gtf(1)
POINTPROP STH log($1^2)
~~~
Then the result of AUTO for the critical point above becomes:
~~~
+ Critical point no. 9
  Crystallogrpahic coordinates: 0.65183 0.90869 0.72597
  Cartesian coordinates: 12.89298 22.10026 33.60159
  Type : (3,-1)
  Field value (f): 4.939109713E-03
  Field value, valence (fval): 4.939109713E-03
  Gradient (grad f): -9.5115E-18 3.8415E-17 4.1112E-18
  Gradient norm (|grad f|): 3.978845324E-17
  Laplacian (del2 f): 1.312332087E-02
  Laplacian, valence (del2 fval): 1.312332087E-02
  Hessian eigenvalues: -2.11139E-03 -1.48096E-03 1.67156E-02
  Hessian:
    -2.068242883E-04  -5.185807347E-03   1.179735612E-03
    -5.185807347E-03   1.373314257E-02  -4.510661176E-03
     1.179735612E-03  -4.510661176E-03  -4.029974096E-04
  mygtf (gtf(0)): 4.112914774E-04
  sth (log($0^2)): -1.062114037E+01
~~~
The properties in the list are calculated at the end. The properties
list is also used in other parts of critic2, notably in the output of
POINT (`Points (POINT)`_).

Any arithmetic expression can be used in POINTPROP, but it is common
to use on of the chemical functions from the critic2 function library
(`List of available functions`_). The shorthand names for the chemical
functions can also be used to apply those functions to the reference
field. For instance:
~~~
POINTPROP GTF
~~~
activates the calculation of the Thomas-Fermi kinetic energy density
(gtf function) on the reference field. POINTPROP can only be used with
arithmetic expressions involving known fields. The keyword CLEAR
deletes all the properties in the list. The list of properties can be
accesed at any time using POINTPROP LIST.

## Graphical representations of gradient paths

### Overview

Gradient paths are the solution of the differential equation x' =
grad(f(x)) where f is a scalar field. They play an important role in
QTAIM theory because gradient paths of the electron density can not
cross the boundary between atomic regions and, as a consequence, a
gradient path plot is a simple way to investigate the shape and
properties of a basin. Gradient paths originate at maxima (if the
field is the density they are usually the nuclei) and end at the
minima (the crystal voids) or at infinity in case of a gas-phase
molecule.

There are two keywords for gradient path representation in critic2:
GRDVEC (2D gradient paths plus a contour plot) and FLUXPRINT
(3D). 

### Gradient path representations in a plane (GRDVEC)

~~~
GRDVEC
   {FILES|ROOT|ONAME} rootname.s
   PLANE x0.r y0.r z0.r x1.r y1.r z1.r x2.r y2.r z2.r
   SCALE sx.r sy.r
   EXTENDX zx0.r zx1.r
   EXTENDY zy0.r zy1.r
   OUTCP sx.r sy.r
   HMAX hmax.r
   ORIG x.r y.r z.r atr.i up.i down.i
   CP cp.i up.i down.i
   CPALL
   BCPALL up.i down.i
   RBCPALL bup.i bdown.i rup.i rdown.i
   CHECK
        x.r y.r z.r
        ...
   ENDCHECK/END
   CONTOUR {F,GX,GY,GZ,GMOD,HXX,HXY,HXZ,HYY,HYZ,HZZ,LAP} 
     nptsu.i nptsv.i {LIN niso.i [cini.r cend.r]|
     LOG niso.i [zmin.r zmax.r]|ATAN niso.i [zmin.r zmax.r]|
     BADER|i1.i i2.i...}
ENDGRDVEC/END
~~~
GRDVEC plots a plane containing all the gradient paths originating
from a set of points. The GRDVEC environment accepts a set of input
lines (in any order) that control the characteristics of the plot. The
syntax of GRDVEC originated from (and is similar to) Bader's AIMPAC
suite of programs.

By using the FILES keyword (equivalently, ROOT or ONAME), the user
sets the root name of the output files containing the information for
the plot (default: <root>). These files include:

* <root>.grd : gradient path data.

* <root>.dat : values of the field on thea plane.

* <root>.iso, <root>.neg.iso : positive (green) and negative (blue)
  contour lines. 

* <root>.gnu : gnuplot script file that generates the merged
  gradient/contour plot.

* <root>-label.gnu : gnuplot script file loaded in <root>.gnu
  containing the information for the position of the CPs in the plot
  plane.

PLANE specifies the plane for the plot using three points: x0 is the
origin, x1 the end of the x-axis and x2 the end of the y-axis. These
points are in crystallographic coordinates in a crystal, and in
molecular Cartesian coordinates in a molecule (default units:
angstrom). The two axes of the plane can be scaled using the SCALE
keyword. If sx.r (sy.r) is given, the total length of the x-axis
(y-axis) is scaled by sx.r (sy.r). If EXTENDX is used, extend the
x-axis by zx0.r (initial point of the x-axis) and zx1.r (end
point). The keyword EXTENDY performs the equivalent operation on the
y-axis. The units for EXTENDX and EXTENDY are bohr (crystals) or
angstrom (molecules) unless changed by the UNITS keyword.

The plot plane may contain regions that are traversed by gradient
lines originating at critical points located outside the plot
region. If this is the case, the OUTCP option allows the user to
extend the plane when considering which origins to be included. The
sx.r and sy.r are scale parameters. The x-axis extends (sx.r-1)*l(x)
in each direction, where l(x) is the axis length. The sy.r variable
works the same way. Consequently, the plane determined by the
vectors given in PLANE acts as a clipping plane while the scaled
plane determines the gradient path origins.

With HMAX, you can set the maximum distance from a CP to the plane
to be included in the plot (units: bohr in crystals, angstrom in
molecules). Default: 1d-4 bohr. 

The ORIG keyword adds a source of gradient lines to the plot. Its
coordinates are x.r, y.r and z.r. Crystallographic coordinates are
used in a crystal, and molecular Cartesian coordinates in a molecule
(default units: angstrom). atr.i is 1 if the point is to be treated as
a ncp or ccp (the up and down trajectories start from points located
on a sphere centered on the origin) and it is 0 if the point is to be
treated as a bcp or ccp (a circle is built around the CP in the plane
determined by two eigenvectors whose eigenvalues have equal sign. The
remaining eigenvector determines a unique direction). up.i and down.i
are the number of gradient paths to be started in the upwards and
downwards direction respectively.

The CP keyword accepts a critical point identifier from the complete
CP list (or the complete atom list). The number of upwards and
downwards gradient paths must be given. A special case is the CPALL
keyword, which adds as origins every critical point in the CP list on
the selected plane. The default number of gradient paths is 36 down
for ncps and 36 up for ccps, and 2 up and 2 down for bcps and
rcps. The BCPALL keyword is similar to CPALL, except that only the
bond critical points are included as origins. If BCPALL is used, the
user must supply the number of gradient lines in the upwards and
downwards directions. In a similar way, RBCPALL includes bond and ring
critical points, and the user must give the number of upwards and
downwards gradient paths for bonds (bup.i, bown.i) and rings (rup.i,
rdown.i).

The CHECK environment allows the user to enter the crystallographic
coordinates of a CP of the scalar field to add it as an origin. If the
point given is not a CP or if it lies out of the selected plane, it is
ruled out of the origin list. The valid CPs in the CHECK list are
identified and an adequate number of gradient paths are started
according to its character: for a ncp and ccp, 36 upwards or downwards
and for a bcp or rcp, 2 upwards and 2 downwards.

The CONTOUR keyword makes critic2 generate a plot in which the
gradient paths calculated in GRDVEC are merged with a contour plot, in
the spirit of PLANE CONTOUR (see `Planes and contour plots
(PLANE)`_). The scalar field for the contour plot can be selected with
F (current reference field), GX, GY,... The syntax for the derivatives
is the same as in PLANE. After this, the user needs to specify the
number of points in each direction of the plane (nptsu.i and nptsv.i)
and the contour values and type of mapping. The isovalue distribution
can be: logarithmic (LOG, with niso.i contours), arctangent (ATAN,
with niso.i contours), same as in the aimpac program (BADER,
{1,2,4,8}x10^{-3,-2,-1,0,1}), linear (LIN, niso.i contours from r0.r
to r1.r), or the user can specify the contour values manually (no
keyword). In LOG and ATAN, the default contours range from the minimum
to the maximum value of the field in the plot. These quantities can be
changed by passing the optional zmin.r and zmax.r parameters to
LOG/ATAN.

Note that GRDVEC is able to handle non-orthogonal axis. If
the two plane axis determined in the PLANE keyword are
non-orthogonal, the final graph will correctly reflect the actual
appearance of the plane by conserving the original angle between the
x- and y- axis.

Also, note that at most 2 gradient lines may be traced from bcps and
rcps, either upwards or downwards. Thus, for example, BCPALL 2 2 is
equivalent to BCPALL 2 100 or BCPALL 100 100.

### Three-dimensional gradient path representations (FLUXPRINT)

~~~
FLUXPRINT
  POINT {1|-1|0} x.r y.r z.r [step.r epsi.r]
  NCP cp.i ntheta.i nphi.i [step.r epsi.r]
     [LVEC x.i y.i z.i]
  BCP cp.i 1 [step.r epsi.r] [LVEC x.i y.i z.i]
  BCP cp.i {0|-1} n.i [step.r epsi.r]
     [LVEC x.i y.i z.i]
     [BRAINDEAD|QUOTIENT|DYNAMICAL]
  RCP cp.i -1 [step.r epsi.r] [LVEC x.i y.i z.i]
  RCP cp.i {0|1} n.i [step.r epsi.r]
     [LVEC x.i y.i z.i]
     [BRAINDEAD|QUOTIENT|DYNAMICAL]
  CCP cp.i ntheta.i nphi.i [step.r epsi.r]
     [LVEC x.i y.i z.i]
  GRAPH igraph.i [step.r epsi.r]
  COLOR r.i g.i b.i
  TEXT|TESSEL|TESS|OBJ|PLY|OFF|CML
  SHELLS ishl.i
  NOSYM
ENDFLUXPRINT/END
~~~
The FLUXPRINT keyword prints three-dimensional gradient paths.  There
are several plotting comands:

- POINT: build a gradient path starting at point (x.r y.r z.r) in
  crystallographic coordinates (crystals) or in molecular Cartesian
  coordinates (molecules, default unit: angstrom). step.r is the
  maximum step (Cartesian coordinates) for the gradient path tracing
  algorithm. If step.r > 0, use it also as the initial step. If step.r
  < 0, use a small step as initial (1d-3). epsi.r is the gradient norm
  stop criterion. The default values are 0.1 for step and 1e-9 for
  epsi. The {1|-1|0} field controls the direction of the path. An
  ascending gradient path is obtained with 1 while -1 issues a
  descending path. 0 = -1 + 1 makes FLUXPRINT represent both ascending
  and descending paths.

- NCP: print gradient paths starting from a (small) sphere centered on
  the nuclear CP identified by cp.i (this identifier comes from the
  complete CP list). The number of points is controlled by ntheta.i
  (number of points sampling the azimuthal angle) and nphi.i (number
  of points sampling the polar angle). cp.i specifies a ncp in the
  main cell up to a lattice translation. The LVEC optional keyword
  allows the user to enter a lattice vector to displace the
  represented ncp gradient paths from their position given in the
  complete cp list written by AUTO.

- BCP: print gradient paths starting at the vicinity of a bond CP,
  identified by cp.i. If the gradient path is ascending (1 in the
  fourth field), the (unique) bond path associated to the bcp is
  represented. If -1 is given instead, the IAS associated to the bcp
  is sampled starting from a small circle surrounding the bcp, with
  n.i points on it. With a 0 value, both tasks are performed.

  The three keywords BRAINDEAD, QUOTIENT and DYNAMICAL establish the
  method employed in generating the starting angular grid. With
  BRAINDEAD, critic2 uses a uniform angular grid. Using QUOTIENT, the
  uniform grid is remapped by x^(l1/l2) where l1 and l2 are the two
  negative eigenvalues at the bcp. This way, the points get
  accumulated around the bcp with lowest eigenvalue (highest if
  absolute value is taken). DYNAMICAL uses a linearized model of the
  interatomic surface and predicts the initial angles critic2 has to
  take in order to generate a uniform distribution of points a given
  distance away. This distance is calculated as 90% of the distance
  to the nearest ccp found in a coarse exploration of the IAS
  omega-limits. Unfortunately, this algorithm works only in cases
  where the bcp has significant but not too large
  ellipticty. Also, there is no gain in using this method in cases
  where the number of ccps is different than 4.

  By default, BRAINDEAD is used. H1 is experimental.

- RCP: print gradient paths starting at the neighbourhood of a ring
  CP. The situation is analogous to that of the bcps.

- CCP: print gradient paths starting at the vicinity of a cage
  CP. Again, the situation is symmetric to the ncp case.

- GRAPH: represent the complete graph in the unit cell. This means:

  * All the bond paths for which both ncps and the bcp lay inside
    the main unit cell.

  * All the ring paths for which both ccps and the rcp lay inside
    the main unit cell.

  The critical points on the boundary of the main cell are also
  represented.

  The igraph.i value represents the quantity of information that is
  to be printed. It is a sum of values, each representing an element
  to plot:

  * 1 : print ring paths associated to the rcps.

  * 2 : print bond paths associated to the bcps.

Several parameters of FLUXPRINT can be changed. The color to be
applied to the paths resulting from subsequent FLUXPRINT commands can
be changed using the COLOR keyword (three integers from 0 to 255 for
the red, green, and blue components). By default, NCP uses the color
corresponding to the originating atom, and a gold color is used
otherwise. The format of the output file can be controlled with the
following keywords: TEXT (plain text file), TESS or TESSEL (tessel),
OBJ (Wavefront obj), PLY (ply format), OFF (Geomview's off), and CML
(Chemical Markup Language). The CML format, which can be read with the
avogadro program, is used by default. The color specs are not used in
CML format. To keep the number of points manageable, critic2 writes
one gradient path point every certain distance is advanced. 

Finally, the SHELLS keyword applies only to graph and graphcp. It
represents the number of unit cell shells where the graph is going
to be plotted. Thus, 0 represents the main unit cell; 1, the main
unit cell and its 26 neighbours; and so on. By default, SHELLS
adopts the -1 value, which is equivalent to 0 for the graph
keyword and means that the partial graph generated in graphcp is
not expanded through symmetry.

NOSYM: do not use symmetry operations. Using this keyword, the
complete list of CPs in the unit cell is written, together with the
identity matrix as the only operation in the space group.

## Atomic basin representations

### Attractor basin plots (BASINPLOT)

~~~
BASINPLOT [CUBE [lvl.i] | TRIANG [lvl.i] | 
  SPHERE [ntheta.i nphi.i]]
  [OFF|OBJ|PLY|BASIN|DBASIN [npts.i]}]
  [CP cp.i] [PREC delta.r] [VERBOSE] [MAP id.s|"expr"]
~~~
Plot the attraction basin of the CP cp.i from the complete list (if CP
is not given, all the non-equivalent attractors are used). The rays on
which the bisection is carried out are determined by the method
chosen. With CUBE, a cube is selected as the starting polyhedron, and
recursively subdivided lvl.i times. The final (convex) polyhedron is
placed on the attractor and the zero-flux surface limit for the rays
is determined. TRIANG follows the same process, starting from an
octahedron. SPHERE stands for a direct triangulation of the unit
sphere. There are nphi.r parallels. The equatorial circles contain
exponentially more points than the polar. Ntheta.i thus represents a
seed. The total number of points is given by the formula
2*nphi*(2**ntheta-1)+2.

The output keyword selects the output format for the basin plot: OFF,
OBJ, PLY, BASIN, and DBASIN. Note that DBASIN files also contain
information about scalar fields measured along the basin rays.

The naming scheme of the output files is <root>-cp.ext where root is
the general root of the run (the name of the input file up to the
first dot unless changed by the ROOT keyword), cp is the complete CP
list id. of the attractor and ext is the appropriate extension (off,
basin or dbasin)

The precision of the bisection is delta.r (set using the PREC
keyword). VERBOSE gives more information in the output about the
bisection process.

If a 3d model format is used (OFF, OBJ, PLY), the MAP keyword can be
utilized to colormap a given field (given by the field number or
identifier id.s) or field-containing expression ("expr") onto the
surface. The color scale limits are the minimum and the maximum value
of the field or expression on all the points of the surface. The
mapping function is the same as in gnuplot (r=sqrt(x), g=x^3,
b=sin(360*x), with x from 0 to 1).

Default: TRIANG method, lvl.i = 3, ntheta.i = nphi.i = 5, OBJ output,
phtheta.r = 0d0, phphi.r = 0d0, all the non-equivalent attractors
found in AUTO.

### Primary bundle plots (BUNDLEPLOT)

~~~
BUNDLEPLOT x.r y.r z.r
  [CUBE [lvl.i] | TRIANG [lvl.i] | SPHERE [ntheta.i nphi.i]]
  [OFF|OBJ|PLY|BASIN|DBASIN [npts.i]}]
  [ROOT root.s] [PREC delta.r] [VERBOSE] [MAP id.s|"expr"]
~~~
Plot a primary bundle starting from a point in its interior, given by
x.r y.r z.r in crystallographic coordinates (crystal) or molecular
Cartesian coordinates (molecule, default units: angstrom). The
bisection algorithm is used with precision delta.r (PREC keyword,
default: 1d-5 bohr). The rays traced are obtained by a recursive
subdivision (lvl.i cycles) a cube (CUBE), an octahedron (TRIANG) or
using a uniform distribution of ntheta.i * nphi.i points on the unit
sphere (SPHERE). The output file has root root.s, and its format may
be OFF, OBJ, PLY, BASIN or DBASIN with npts.i points sampled along
each ray. The initial polyhedron may be rotated a phase given by
phtheta.r (polar angle) and phphi.r (azimuthal angle).

If a 3d model format is used (OFF, OBJ, PLY), the MAP keyword can be
utilized to colormap a given field (given by field number or
identifier id.s) or field-containing expression ("expr") onto the
surface. The color scale limits are the minimum and the maximum value
of the field or expression on all the points of the surface. The
mapping function is the same as in gnuplot (r=sqrt(x), g=x^3,
b=sin(360*x), with x from 0 to 1).

Default values: TRIANG, lvl.i = 3, ntheta.i = nphi.i = 5, OBJ output,
phtheta.r = 0d0, phphi.r = 0d0, root.s = <root>-bundle.

## Integration of atomic basins

### Overview

Critic2 provides several methods to integrate the attractor basins
associated to the maxima of a field. In QTAIM theory, this field is
the electron density, the attractors are (usually) nuclei and the
basins are the atomic regions. In this case, the integrated properties
are atomic properties (e.g. atomic charges, volumes, moments,
etc.). The attractor basins are defined by a zero-flux condition of
the electron density gradient: no gradient paths cross the boundary
between attractor regions. This makes the basins local to each
attractor, but their definition yields a relatively complex
algorithmic problem.

The simplest way of integrating an attractor basin is bisection. A
number of points distributed in a small sphere around the atom are
chosen, each of them determining a ray. On each ray, a process of
bisection is started. A point belongs to the basin if the gradient
path traced upwards ends up at the position of the attractor we are
considering. If the end-point is a different attractor, then the point
is not in the basin. By using bisection, it is possible to determine
the basin limit (called the interatomic surface, IAS). The bisection
algorithm is implemented in critic2, and can be accessed with the
INTEGRALS keyword.

An algorithm has been proposed based on the recursive subdivision of
the irreducible Wigner-Seitz (IWS) cell, called qtree. In qtree, the
smallest symmetry-irreducible portion of space is considered and a
tetrahedral mesh of points is superimposed on it. The gradient path is
traced from all those points and the points are assigned to different
atoms (the points are 'colored'). The final integration is performed
by quadrature. The qtree algorithm is accessed through the QTREE
keyword.

Lastly, integration algorithms based on grid discretization are very
popular nowadays thanks to the widespread use of
pseudopotential/plane-waves DFT methods. Critic2 provides the
integration method of Yu and Trinkle (YT), described in JCP 134 (2011)
064111. The algorithm is based on the assignment of integration
weights to each point in the numerical grid by evaluating the flow of
the gradient using the neighboring points. This algorithm is extremely
efficient and robust and is strongly recommended in the case of fields
on a grid. The keyword is YT. Another alternative for grids is the
method proposed by Henkelman et al. (Comput. Mater. Sci. 36, 254-360
(2006), J. Comput. Chem. 28, 899-908 (2007), J. Phys.: Condens. Matter
21, 084204 (2009)), which is implemented in critic2 using the keyword
BADER.

The field that determines the basins being calculated is always the
reference field (see `The reference field (REFERENCE)`_). However, it
is in general interesting to one or more integrable properties using
other scalar fields. For instance, we can calculate the charge inside
an ELF basin: the ELF would be the reference field and the electron
density would be an integrable property.

### List of properties integrated in the attractor basins (INTEGRABLE)

~~~
INTEGRABLE id.s {F|FVAL|GMOD|LAP|LAPVAL} [NAME name.s]
INTEGRABLE id.s {MULTIPOLE|MULTIPOLES} [lmax.i] 
INTEGRABLE id.s DELOC [NOU] [NOSIJCHK] [NOFACHK] [WANCUT wancut.r]
INTEGRABLE "expr.s" 
INTEGRABLE CLEAR
INTEGRABLE ... [NAME name.s]
~~~
Critic2 uses an internal list of all properties that will be
integrated in the attraction basins. This list can be modified by the
user with the INTEGRABLE keyword. This keyword has a syntax similar to
the list of properties calculated at the critical points (`List of
properties calculated at points (POINTPROP)`_).

A single INTEGRABLE command assigns a new quantity to be integrated in
the atomic basins. The new integrable property is related to field
id.s (given as field number or identifier). This quantity can be the
field value itself (F), its valence component (if the field is
core-augmented, FVAL), the gradient norm (GMOD), the Laplacian (LAP),
or the valence-component of the Laplacian (LAPVAL). If no keyword is
given after id.s, F is used by default.

With the MULTIPOLES (or MULTIPOLE) keyword, the multipole moments of
the field are calculated up to l=lmax.i (default: 5). This keyword
only applies to the BADER and YT integration methods; for the others,
it is equivalent to the field value (same as F). The units for all
calculated multipoles are atomic units.

The keyword DELOC activates the calculation of the delocalization
indices using field id.s via maximally localized wannier functions
(see `Integrating delocalization indices in a solid with maximally
localized Wannier functions`_). 

In addition, it is possible to define an integrable property using an
expression involving more than one field (expr.s). For instance, if
the spin-up density is in field 1 and the spin-down density is in
field 2, the atomic moments can be obtained using:
~~~
LOAD AS "$1+$2"
REFERENCE 3
INTEGRABLE "$1-$2"
~~~
Note that the double quotation marks are required. 

The additional keyword NAME can be used with any of the options above
to change the name of the integrable property, for easy identification
in the output.

The keyword CLEAR resets the list to its initial state (volume, charge
and Laplacian). Using the INTEGRABLE keyword will print a report on
the list of integrable properties.

The default integrable properties are:

* Volume (1)

* Pop (fval): the value of the reference field is integrated. If the
  reference field is the density, then this is the number of electrons
  in the basin. If core augmentation is active for this field, only
  the valence contribution is integrated.

* Lap (lap(fval)): the Laplacian of the reference field. The
  integrated Laplacian has been traditionally used as a check of the
  quality of the integration because the exact integral is zero
  regardless of the basin (because of the divergence
  theorem). However, it is difficult to obtain a zero in the Laplacian
  integral in critic2 because of numerical inaccuracies:

  - In fields based on a grid, the numerical interpolation gives a
    noisy Laplacian.

  - In FPLAPW fields (WIEN2k and elk), the discontinuity at the muffin
    surface introduce a non-zero contribution to the integral.

  If f is a core-augmented field, only the valence Laplacian is
  integrated. 

#### Integrating delocalization indices in a solid with maximally localized Wannier functions

The keyword DELOC activates the calculation of localization and
delocalization indices (DIs) in a crystal using the procedure
described in http://dx.doi.org/10.1021/acs.jctc.8b00549 . DIs can be
calculated only if the loaded field contains information about
individual Kohn-Sham states and the orbital rotation that leads to the
maximally localized Wannier functions (MLWF). This is done by using a
field loaded from a pwc file (generated by the pw2critic.x utility in
Quantum ESPRESSO) together with a checkpoint (chk) file from
wannier90. The former contains the electronic wavefunctions and the
latter the orbital rotation (`QE wavefunction plus Wannier checkpoint
files (pwc)`_) . For maximum consistency, the pwc file can also be
used to provide the structural information for the run via the CRYSTAL
keyword (see `Quantum ESPRESSO wavefunction (pwc)`_).

In addition to these data, the calculation of DIs has a few
requirements: the grid must be consistent with that of the reference
field, and the DIs can be calculated using YT or BADER only. 

A typical delocalization index calculation comprises the following
steps:

- Run a PAW calculation, then obtain an all-electron density using
  pp.x with plot_num=21. This creates a cube file (rhoae.cube) that
  gives the Bader basins for the calculation (the pseudo-valence
  density is not valid for this purpose).

- Run an SCF calculation with norm-conserving pseudopotentials and the
  same ecutrho as the calculation in the first step, so the two grids
  have the same sizes.

- Use the open_grid.x utility in Quantum ESPRESSO to unpack the
  symmetry of the k-point grid, in preparation for the wannier90 run
  (this would normally be accomplished by a non-SCF calculation, but
  with open_grid.x it is easier and much faster).

- Use pw2critic.x on the output of open_grid.x to generate the pwc
  file. 

- Run wannier90 on the result of open_grid.x to generate the chk file.

- Load the all-electron density and the pwc and chk files as two
  fields in critic2. Set the former as the reference density and the
  latter as INTEGRABLE DELOC. If the system is spin-polarized, two
  checkpoint files will be necessary, one for each spin component (see
  the FeO case in the dis_wannier example).

- Run YT or BADER.

For detailed examples, please check the "dis_wannier" subdirectory in
the examples/ directory of the critic2 distribution.

Additional options for the DI calculation follow.  The NOU options
disables the use of the U matrices to calculate the MLWFs. This makes
critic2 calculate the DI using Wannier functions calculated using a
straight Wannier transformation from the Bloch states. This is
naturally much slower than the maximally localized version, and should
be used only if wannier90 failed to converge for the particular case
under study.

By default, two checkpoint files are generated during a DI calculation
run. These files have the same name as the pwc file but with "-sij"
and "-fa" suffixes. The former checkpoint file contains the atomic
overlap matrices, and the latter, the F integrals required for the DI
calculation. The presence of any of these two files makes critic2 read
the information from the files and bypass the corresponding
calculations, which are very time consuming in general. The keywords
NOSIJCHK and NOFACHK deactivate reading and writing these checkpoint
files. 

By default, the overlap between two MLWFs whose centers are a certain
distance away are discarded. The WANCUT keyword controls this
distance: wancut.r times the sum of their spreads. By default,
wancut.r = 4.0. A very large wancut.r will prevent critic2 from
discarding any overlaps. The appropriateness of the chosen WANCUT can
be checked a posteriori by comparing the integrated electron
population obtained by sum of the localization and delocalization
indices to the value obtained from a straight integration of the
electron density.

### Bisection (INTEGRALS and SPHEREINTEGRALS)

~~~
INTEGRALS {GAULEG ntheta.i nphi.i|LEBEDEV nleb.i}
          [CP ncp.i] [RWINT] [VERBOSE]
~~~
Integrate the attractor basins using bisection. Ntheta.i and nphi.i
are the number of theta (polar angle) and phi (azimuthal angle)
points for the Gauss-Legendre quadrature, if GAULEG is used. The
number of azimuthal angles depends on the actual value of the polar
angle (theta) and is adapted according to the formula:

    realnphi = int(nphi.i * sin(theta)) + 1

In the case of a Lebedev-Laikov quadrature, the number of points of
the radial Gauss-Legendre grid and the octahedral grid is needed. The
actual value of nleb.i is the smallest number larger than the one
given by the user included in the list: 6, 14, 26, 38, 50, 74, 86,
110, 146, 170, 194, 230, 266, 302, 350, 434, 590, 770, 974, 1202,
1454, 1730, 2030, 2354, 2702, 3074, 3470, 3890, 4334, 4802, 5294,
5810.

By using the CP keyword, a single non-equivalent CP (ncp.i) is
integrated. Otherwise, all the CPs of the correct type (found using
AUTO) are integrated. If RWINT is present, read (if they exist) and
write the .int files containing the interatomic surface limit for
the rays associated to the chosen quadrature method.

Defaults: ntheta.i = nphi.i = 50, nleb.i = 4802.

~~~
SPHEREINTEGRALS {GAULEG ntheta.i nphi.i|
                 LEBEDEV nleb.i} [CP ncp.i] [NR npts.i]
                [R0 r0.r] [REND rend.r]
~~~
Integrates the volume, field and Laplacian in successive spheres
centered around each of the attractor CPs. The same considerations
for GAULEG and LEBEDEV as in the keyword above apply.

A total number of npts.i spheres are integrated per nucleus. The grid
is logarithmic, so that the region near the nucleus has a higher
population of points. The grid starts at the radius r0.r and ends at
rend.r (bohr in crystals, angstrom in molecules). If rend.r < 0 then
the final radius is taken as half the nearest neighbor distance for
each atom times abs(rend.r).

Default: npts.i = 100. In GAULEG, ntheta.i = 20 and nphi.i = 20. In
LEBEDEV, nquad.i = 770. r0 = 1d-3 bohr. rend = rnn/2 for each CP. id.i
= 0 (all attractors).

### Qtree (QTREE)

~~~
QTREE_MINL minl.i
GRADIENT_MODE gmode.i
QTREE_ODE_MODE omode.i
STEPSIZE step.r
ODE_ABSERR abserr.r
INTEG_MODE level.i imode.i
INTEG_SCHEME ischeme.i
KEASTNUM k.i
PLOT_MODE plmode.i
PROP_MODE prmode.i
MPSTEP inistep.i
QTREEFAC f.r
CUB_ABS abs.r
CUB_REL rel.r
CUB_MPTS mpts.i
AUTOSPH {1|2}
SPHFACTOR {ncp.i fac.r|at.s fac.r}
SPHINTFACTOR atom.i fac.r
DOCONTACTS
NOCONTACTS
WS_ORIGIN x.r y.r z.r
WS_SCALE scale.r
WS_EPS_VOL eps_vol.r
KILLEXT
NOKILLEXT
CHECKBETA
NOCHECKBETA
PLOTSTICKS
NOPLOTSTICKS
COLOR_ALLOCATE {0|1}
SETSPH_LVL lvl.i
VCUTOFF vcutoff.r
QTREE maxlevel.i plevel.i
~~~
The QTREE integration method is a new algorithm capable of calculating
the QTAIM atomic properties in a more efficient way than the bisection
approach. QTREE is specific to solid-state problems, and is based on a
hierarchical subdivision of the irreducible part of the WS cell,
employing a tetrahedral grid. The integration region is selected so as
to maximize the use of symmetry, and partitioned into
tetrahedra. These tetrahedra enter a recursive subdivision process in
which each of them is divided in 8 at each level, up to a level given
by the user, the maxlevel.i indicated after the QTREE keyword
(default, 6). Every tetrahedron vertex is assigned to a non-equivalent
atom in the unit cell by tracing a gradient path. Finally, the
tetrahedra are integrated and the properties assigned to the
corresponding atoms. The space near the atoms is integrated using a
beta-sphere, a method that proves more accurate despite generating a
second interface in the atomic basin.

In the simplest approach, qtree can be executed using:
~~~
QTREE [maxlevel.i]
~~~
where maxlevel.i is the level of subdivision. The optional plevel.i
value corresponds to the pre-splitting level of the tetrahedra. The
initial tetrahedra list is split into smaller tetrahedra plevel.i
times. This can be useful in cases where a very high accuracy (and
therefore a very high level) is required, but there is not enough
memory available to advance to higher maxlevel.i. However, using
plevel.i incurs in a overhead, because the painting procedure is not
as efficient when smaller tetrahedra are used.

Note: parallelization might not work with older versions of
ifort. The newer versions of gfortran do work with parallel qtree.

The steps of the algorithm are:

* The WS cell is constructed and split into tetrahedra, all of which
  have in common, at least, the origin. Then, the site symmetry of
  the origin is calculated and the tetrahedra that are unique under
  the operations of this group are found. This is what we call the
  irreducible Wigner-Seitz cell (IWS). Note, however, that it is only
  'irreducible' in the local symmetry of the origin, not by the full
  set of space group operations. The IWS is the region that is to be
  integrated in later steps of QTREE. We will refer to single IWS
  tetrahedra as IWST.

  It is possible, through the WS_ORIGIN keyword, to shift the origin
  of the WS cell away from the (0 0 0) position. Using the procedure
  above, the number and shape of IWST changes depending on the origin
  chosen. Trivially, a general position will make the IWS exactly
  equal to the WS.

  Also, for large systems, the user can choose to shrink the size of
  the original WS cell in order to integrate a smaller region, using
  the WS_SCALE keyword (most likely in combination with WS_ORIGIN, to
  move the region around). If a value is given to WS_SCALE (say rws),
  then all the vectors connecting the origin of the WS cell with the
  vertex are shrunk by a factor rws, therefore decreasing the volume
  by a factor rws**3 . The IWS is calculated using the smaller WS
  cell and integrated in the same way. Note that this integration
  region is non-periodic: it does not fill the volume of the solid
  and it does not integrate to the total number of electrons per
  cell.

* Non-overlapping spheres are chosen centered on each of the atoms of
  the cell, the so-called beta-spheres. Atoms equivalent by symmetry
  share the same beta-sphere radius (say beta_i for atom i). The
  beta-sphere takes two roles in QTREE:

  -  The atomic properties are integrated inside the beta-spheres
     using a 2d cubature. The cubature can be a product of two 1d
     Gauss-Legendre quadratures or a Lebedev quadrature of the
     sphere. Both methods, and the number of nodes can be selected
     using the INT_SPHEREQUAD_* keywords explained below. The radial
     quadrature can be any of the available in critic, and is
     controlled by the INT_RADQUAD_* options. The default values,
     however, are usually fine, integrating the beta-spheres in a
     matter of seconds with a precision that is orders of magnitude
     better than the overall QTREE performance.

     This beta-sphere integration removes the error of the
     finite-elements integration of a region where the integrated
     scalar fields present the steeper variations in value. By
     removing the high-error regions from the grid integration, the
     accuracy of QTREE is enhanced. In particular, this increase in
     precision outweighs the loss by creating an additional
     interface between the grid and the sphere.

  - The space inside the beta-sphere of an atom is assumed to be
    inside the basin of that atom. The terminus of any gradient
    path that reaches the interior of the beta-sphere i is assumed
    to be the atom i. It is known that most of the steps in the
    integration of the gradient of the electron density are spent
    in the close vicinity of the terminus. Therefore, this
    modification saves precious function evaluations.

  The default beta-sphere radius is set to 0.80 times half the
  nearest-neighbor distance. Both i) and ii) above assume that the
  beta-sphere is completely contained inside the basin of the
  atom. This may turn out not to be true for the default beta-sphere
  radius (specially for cations in ionic systems). In these cases, the
  keyword SPHFACTOR is used. Its syntax is:
~~~
SPHFACTOR 1 0.70   ! Make b_1 = 0.70 * rNN2(1) (atom type 1)
SPHFACTOR 0 0.60   ! Make b_i = 0.60 * rNN2(i) for all atoms
SPHFACTOR Si 0.60  ! Make b_i = 0.60 for all Si atoms
~~~
  If SPHFACTOR < 0, use the scheme by Rodriguez et al. to determine
  the beta-sphere radii (JCC, 30 (2009) 1082-1092): a collection of
  points around the atom are selected and the angle between the
  gradient and the radial direction is determined. If all the angles
  are < 45 degrees, the sphere is accepted. In solids, this strategy
  yields usually spheres that too large.

  In the case that any atomic SPHFACTOR is zero (the default value
  for all atoms), then a pre-computation at a lower level is done to
  ensure that all beta-spheres lie within the desired basins. There
  are two methods for this that can be chosen using AUTOSPH (default:
  method number 2).

  Method number one involves a reduced version of QTREE. The
  pre-computation usually takes no longer than some minutes (and
  usually only few seconds) and the spheres are guaranteed to be
  inside the basins. The keyword SETSPH_LVL controls the level of the
  pre-computation, that must not be higher than 7. The default value
  is 6 or maxl, whichever is smaller.

  The second method (default) traces gradient path on a coarse sphere
  around each nucleus, and reduces the sphere until all of the points
  are inside the basin. NOCHECKBETA is used in this case.

  An additional factor the user can define is the SPHINTFACTOR. It is
  possible to consider the sphere where GPs terminate different from
  the one that is integrated. If SPHINTFACTOR is defined, as in:
~~~
SPHINTFACTOR 1 0.75
~~~
  then the sphere associated to atom 1 where the integration is done
  has a radius which is 0.75 times that of the sphere where GP
  terminate.

  The CHECKBETA and NOCHECKBETA keywords activate and deactivate the
  check that ensures that the beta-spheres is completely contained
  inside the basin.

  If a beta-sphere is not strictly contained in the basin, QTREE
  detects it and stops immediately (specifically, QTREE checks that
  every tetrahedron that is partly contained in a beta-sphere has
  vertex termini that are all assigned to the same atom as the
  beta-sphere owner).

  For a new system, it is always a good idea to start with a
  low-level QTREE (say, level 4) to check if the default beta-spheres
  are adequate. If one of the beta-spheres is too large, the error
  message looks like:
~~~
An undecided tetrahedron is overlapping with a beta-sphere.
Make beta-spheres smaller for this system.
terms:            1          -1           2           1
~~~
  which indicates that there is a tetrahedron that is partly
  contained in the sphere of the first atom (terminus -1) and that
  has a vertex corresponding to atom 2. Modifying the sphfactor
  solves this problem:
~~~
SPHFACTOR 1 0.70
~~~
  At lower levels, QTREE is reasonably fast, so a trial-and-error
  selection of beta-spheres is acceptable.

  Note that the beta-spheres used in QTREE have no relation to the
  ones reported after an AUTO calculation.

* If the cell is periodic (which means that WS_SCALE was not set),
  the contacts between the faces of the IWST are found. These
  contacts are used in a later step to copy the termini information
  between tetrahedron faces.

  The determination of the tetrahedra contacts in a periodic
  integration region is deactivated if the NOCONTACTS keyword is
  issued. The opposite is the DOCONTACTS keyword. By default, the
  contacts are not calculated.

* A grid is built for each of the IWST, for which the termini of the
  gradient paths starting at each of the grid points will be
  calculated. The grid is determined by subdividing the IWST
  qtree_lvl times. In each subdivision step, a parent tetrahedron is
  divided in 8 smaller tetrahedron (all with the same volume, V / 8)
  by splitting each edge of the parent tetrahedron in two. There are
  two possible ways of doing this, the election being irrelevant to
  the performance of QTREE.

  For a given IWST, the size of the grid is given by S =
  n*(n+1)*(n+2)/6 where n = 2**qtree_lvl + 1, the approximate scaling
  being as 8**qtree_lvl . The termini information on the grid is
  saved to the array trm of type integer*1, with size nt * S, where
  nt is the number of IWST (in fact, the integer type is that which
  is the result of selected_int_kind(2)).

  The subdivision level is the main input parameter for QTREE,
  controlling the accuracy (and cost!) of the integration. For
  small-medium sized systems 4-5 are low cost integrations (seconds),
  6-7 are medium cost (minutes) and 8-9 are the slowest and most
  accurate (hours). The level is input in the call to the QTREE
  integration:
~~~
QTREE 6   ! qtree_lvl is 6
~~~
  By default, the integration level is 5.

  In addition to trm, more work space can be allocated if the
  integration is restricted to the volume and charge or to the
  volume, charge and Laplacian. The number and type of properties to
  be integrated is controlled by the PROP_MODE keyword. The following
  values are allowed:

  - 0 - only volume is integrated. This amounts to canceling the
    finite elements integration of tetrahedra and is equivalent to
    INTEG_MODE 0 (see below).

  - 1 - only charge and volume. If the integration uses the value of
    the density at the grid points (INTEG_MODE 11, see below) In
    addition to trm, another real*8 array, fgr, is allocated
    (strictly it is selected_real_kind(14), not real*8). In fgr, the
    value of the density at the grid points is stored.

  - 2 - charge, volume and Laplacian. In a similar way to 1, if the
    information on the grid points is used during the integration
    (INTEG_MODE 11), an additional real*8 array, lapgr, is
    allocated. It contains the value of the Laplacian of the electron
    density at the grid points.

  - 3 - all the integrable properties calculated by the module. The
    number of properties varies with the interface being used. No fgr
    or lapgr are allocated, as the grid points need to be recomputed
    during integration.

  The default value for PROP_MODE is 2.

  The termini of the grid points contained in a beta-sphere is marked
  previous to the beginning of the subdivision.

* Each tetrahedron is subdivided recursively up to a level qtree_lvl,
  and integrated at the same time. The IWST integration is relatively
  independent of one another, so for the moment we will focus on just
  one IWST, which we will call the base tetrahedron.

  The IWST integration is not exactly independent of one another for
  two reasons:

  - When the integration ends, the termini of the four faces of a
    base tetrahedron are copied to its neighbors' trm, according to
    the contacts determined previously.

  - Depending of the method chosen (see GRADIENT_MODE below), the
    gradient path integration may be aware of the neighboring grid
    points, that may very well belong to other IWST. In particular,
    the gradient mode number 3 integrates a gradient path following
    grid points. When the endpoint is reached, all the grid points
    that have been traversed by the path are assigned the same common
    terminus. Therefore, there is the possibility that gradient paths
    starting inside a given base tetrahedron write the trm of other
    IWST.

  Nevertheless, both features can be avoided if there is ever
  interest in parallelizing the integration over IWST.

* A tetrahedra stack is built and initialized only one element: the
  base tetrahedron. An iterator works on the stack, performing at
  each step the following tasks:

  - Pop a tetrahedron from the stack.

  - The termini of the vertex of the tetrahedron are calculated, if
    they are not already known. Let us assume for now that we have
    a method that traces a gradient path and reliably locates the
    terminus for a given grid. This will be treated below.

  - If all the termini of the tetrahedron correspond to the same
    atom, its inside of the tetrahedron is 'painted'. This means
    that all the grid points that are in the interior or border of
    the tetrahedron are assigned the same color as its vertex,
    thereby saving the tracing of the gradient paths.

    This 'painting' can be dangerous whenever a (curved) IAS
    crosses the face of the tetrahedron which undergoes the
    operation. To this end, a minimum level is defined, using the
    keyword QTREE_MINL. If the subdivision level of the tetrahedron
    is lower or equal than QTREE_MINL, the tetrahedron is not
    painted. (Note: the base tetrahedron corresponds to level 0).

    Furthermore, if all the termini correspond to the same atom and
    are located outside of the beta-sphere region, the tetrahedron
    is integrated and does not enter another subdivision
    process. Once more, this only happens to tetrahedra with a
    level of subdivision strictly greater than QTREE_MINL. As we
    did with the gradient path tracing, let us suppose that we have
    at our disposal a method that calculates the integral of the
    selected properties over one of these tetrahedra. We will
    refer to this methods as an 'inner integration method', because
    the value of the properties will be assigned to only one atom.

    On the contrary, if all the termini are located inside the
    beta-sphere region, the tetrahedron does not subdivide, but the
    properties are not integrated, because this region corresponds
    to the sphere integration addressed in point 2.

    If the tetrahedron is in the border of a beta-sphere, it
    is divided further.

  - If the tetrahedron is at subdivision level equal to qtree_lvl,
    then it does not subdivide, it is integrated and the properties
    are assigned to the atoms. There are several possibilities
    depending of the nature of its vertex termini:

    + If all the termini correspond to the same atom, and the
      tetrahedron is completely inside or outside of this atom's
      sphere, it corresponds to a case in 6.3.

    + If it is completely inside an atom basin, but on the border
      of a beta-sphere (remember that being on the border of a
      beta-sphere implies that it is inside the basin), the part of
      the tetrahedron that is outside of the sphere is integrated
      and assigned to the atom. Another integration method is
      required for this, essentially different from the 'inner
      integration'. We will refer to this one as 'border,
      same-color integration'.

    + If the tetrahedron has termini corresponding to different
      atoms, its properties are integrated and split into
      contribution to atoms, according to the number of termini
      each atom has. These tetrahedra are located on the IAS, and
      require a third class of integration, 'border, diff-color
      integration'.

  - A tetrahedron that has not been integrated continues to the
    subdivision step. In this step, 8 new tetrahedra are pushed
    into the stack. To this end, the edges of the parent
    tetrahedron are split in two. Note that, by construction, the
    newly generated points correspond to grid points also.

    The subdivision scheme is:

    + 1, 1-2, 1-3, 1-4
    + 2, 1-2, 2-3, 2-4
    + 3, 1-3, 2-3, 3-4
    + 4, 1-4, 2-4, 3-4
    + 2-3, 1-2, 1-3, 1-4
    + 1-4, 1-2, 2-3, 2-4
    + 1-4, 1-3, 2-3, 3-4
    + 2-3, 1-4, 2-4, 3-4

    where 'a' represents a vertex of the parent tetrahedron and
    'a-b' the midpoint of both vertex. Each of the 8 child
    tetrahedra enclose the same volume, equal to V / 8**l, where l
    is the subdivision level and V is the volume of the base
    tetrahedron. The 4 last subdivisions can be chosen in yet
    another way, but this is not relevant to the results of QTREE.

  - When the stack is empty, the work on the base tetrahedron is
    finished.

* 'Inner integration'. The inner integration applies to tetrahedra
  that are completely contained in the non-beta-sphere region of a
  basin. It can apply to a tetrahedron of any level, as long as it is
  greater than QTREE_MINL. The integrated properties are to be
  assigned to a single atom, so the only problem with inner
  integration is to obtain an accurate value of these integrals.

  In the current implementation of QTREE, several integration methods
  are possible, and are controlled by the INTEG_MODE keyword. The
  possible values of INTEG_MODE are:

  - 11 : use the information of the density, Laplacian and properties
    at the vertex of the tetrahedron to integrate. The integral is
    approximated by a quadrature of four terms, each corresponding to
    a volume that is 1/4 of the volume of the tetrahedron and
    multiplied by the value of the properties at the vertex. This
    integration method is useful if only charge or charge and
    Laplacian are being integrated, because the information gained
    during the gradient path tracing, and saved in the fgr and lapgr
    arrays, is used. Nevertheless, it is not very accurate for large
    tetrahedra.

  - 12 : use the CUBPACK routines. CUBPACK provides an adaptive
    tetrahedron integration method based on recursive subdivision
    (exactly the same as QTREE, by the way) and an integration rule
    with 43 nodes (degree 8), that is equivalent to the DCUTET
    library by Bernsten et al. The integration rule is fully
    symmetric under the Th group operations. The error estimation is
    compared to the error requested by the user, that is controlled
    using the CUB_ABS (absolute error), CUB_REL (relative error) and
    CUB_MPTS (maximum number of function evaluations) keywords. If
    CUB_MPTS is exceeded, an error message is output, but the
    QTREE integration continues.

    Note that, no matter how low the error requirements are, the
    CUBPACK integration spends, at least, 43 function evaluations per
    tetrahedron, so it is quite expensive if compared to other
    integration modes. This should be reserved for large tetrahedra
    (see below) or for really accurate calculations.

  - 1...10 : use a non-adaptive rule from the KEAST library (Keast et
    al., 1986), the number corresponding to:

    + 1  -- order =  1,  degree =  0
    + 2  -- order =  4,  degree =  1
    + 3  -- order =  5,  degree =  2
    + 4  -- order = 10,  degree =  3
    + 5  -- order = 11,  degree =  4
    + 6  -- order = 14,  degree =  4
    + 7  -- order = 15,  degree =  5
    + 8  -- order = 24,  degree =  6
    + 9  -- order = 31,  degree =  7
    + 10 -- order = 45,  degree =  8

    In particular, the first KEAST rule uses the barycenter of the
    tetrahedron.

  The syntax of the INTEG_MODE keyword is:

  INTEG_MODE lvl.i mode.i

  where mode.i is one of the modes above and lvl.i is the level for
  which it applies. This means that, if a tetrahedron of a given
  level is to be integrated, the value of INTEG_MODE(level) is
  checked to decide on the method.

  A last INTEG_MODE value is possible:

  - -1 : do not integrate and force the tetrahedron into the
    subdivision process. This value of INTEG_MODE can be combined
    with a positive value at higher levels, amounting to a recursive
    integration in the style of CUBPACK. Of course, -1 is not an
    acceptable value for the last level, qtree_lvl .

  As setting these INTEG_MODE by hand could be confusing, QTREE
  provides some more-or-less well tested sets of INTEG_MODE values,
  which we will call integration schemes. An integration scheme
  conveys a full set of INTEG_MODEs that span from the lowest to the
  highest level of subdivision. Integration schemes are selected
  using the INTEG_SCHEME keyword, that can assume the following
  values:

  - 0 : do not integrate, only calculate volume and plot (see
    below). This is equivalent to setting PROP_MODE to 0.

  - 1 : subdivide each tetrahedron up to the highest level and then
    integrate using the vertex information. This is most useful if
    PROP_MODE is 1 (only charge and volume) or 2 (charge, volume and
    Laplacian) because the information of the gradient path tracing
    (fgr and lapgr arrays) are used.
    INTEG_MODE = -1 -1 ... -1 11
    !            ^^           ^^
    !        QTREE_MINL    qtree_lvl

  - 2 : subdivide each tetrahedron up to the highest level and then
    integrate using the barycenter.
    INTEG_MODE = -1 -1 ... -1 1.

  - 3 : barycentric integration at all levels of subdivision. Less
    accurate but faster than 2.
    INTEG_MODE = 1 1 ... 1 1.

  - 4 : one of the Keast rules (given by the KEASTNUM keyword) is
    used at all levels. If KEASTNUM is n,
    INTEG_MODE = n n ... n n.

  - 5 : CUBPACK, at all levels. Reserve this one for special
    occasions.
    INTEG_MODE = 12 12 ... 12 12.

  - 6 : this scheme and the next are (poor) attempts at trying an
    adaptive integration scheme. They are not more reliable or
    efficient than, say, the scheme 2. Integration scheme 6
    calculates levels 4, 5 and 6 using CUBPACK, and the rest with
    subdivision up to the highest level and vertex-based
    integration.
    INTEG_MODE = 12 12 12 -1 ... -1 11.

  - 7 : same as 6 but the final integration is based on the
    barycenter.
    INTEG_MODE = 12 12 12 -1 ... -1 1.

  - -1 : let the user enter the INTEG_MODEs by hand.

  The default integration scheme is 2, suitable for low and
  medium-accuracy calculations.

* 'Border, same-color integration'. This integration applies to
  tetrahedra that have reached the maximum subdivision level and sit
  on the interface between a beta-sphere and the atomic basin. Some
  of the vertex are known to be inside the sphere and some of them
  are out. The objective is to integrate the out-of-sphere part and
  summing it to the atomic properties, while ignoring the in-sphere
  part (that has been integrated at the beginning using a sphere
  cubature).

  The integration follows by assuming that the sphere radius is much
  larger than the tetrahedron characteristic lengths and, therefore,
  that the sphere surface can be considered a plane that intersects
  the tetrahedron. The intersection points of the sphere with the
  tetrahedron edges are easily calculated and, for the sake of
  simplicity in the explanation, we will refer to them as the
  'middle' of the edges. Note, however, that in the implementation,
  these points are calculated exactly. There are three possible
  cases:

  - One vertex is outside, three inside. The tetrahedron formed by
    the vertex that is outside and the three middle points of the
    edges that stem for it form a tetrahedron by itself, that is
    integrated and added to the atom properties.

  - Three vertex are outside, one inside. The difference between the
    whole tetrahedron integration and the small tetrahedron inside
    the sphere is added to the atom properties. The small tetrahedron
    is formed by the vertex that is inside the sphere and the three
    edges connected to it.

  - Two vertex are inside, two outside. The region outside of the
    sphere is a 'triangular prism', that is split in three tetrahedra
    and integrated.

  Note that the INTEG_MODE of the maximum subdivision level
  (qtree_lvl) applies to all the sub-integrations of the border,
  same-color integration.

* 'Border, diff-color integration'. As in the case of 'border,
  same-color integration', this method only applies to tetrahedra
  which are at their maximum subdivision level. In this case, the
  termini of the vertex corresponding to, at least, two different
  atoms.

  In the current implementation of QTREE, the tetrahedron is
  integrated as a whole. Then, the properties are equitatively
  assigned to each of the termini atoms. For instance, if the termini
  are (1 1 1 3), the properties of the tetrahedron are integrated,
  then 3/4 of them assigned to atom 1 and 1/4 to atom 3.

  In the literature, this problem has been addressed (although in
  cubes, not in tetrahedra) by using a Monte-Carlo integration inside
  the region. This requires tracing a gradient path for each of the
  random points, to achieve a overall accuracy that scales as sqrt(N)
  where N is the number of nodes. However, I feel that, if this type
  of approach is to be used, then it is better to continue
  subdividing the tetrahedron, in a way that is equivalent to going
  to a higher QTREE level, that scales as N.

* Gradient path tracing. The gradient path start always at grid
  points, and are traced using one of three methods, controlled by
  the GRADIENT_MODE keyword, that can assume the following values:

  - 1 : 'full gradient'. This method is ODE integration as it is
    meant to be. The integration is carried out ignoring the grid
    information. As was explained before, the gradient path is
    terminated whenever it enters a beta-sphere region.

  - 2 : 'color gradient'. At each point of the gradient path, the
    neighboring grid points are checked. If all of them correspond
    to the same atom, then the terminus of the gradient path is
    assigned to that atom.

    In a tetrahedral mesh, the meaning of 'neighboring grid points'
    is not as clear as in a cubic mesh. For a given point x, the
    neighbors are calculated by first converting x to convex
    coordinates, that range from 0 to 2**l (restricted to x_1 + x_2
    + x_3 <= 2**l). The neighboring points are:
~~~
(x_1 +- 1, x_2 +- 1, x_3 +- 1)
~~~
    If any of these neighbors are not valid points in the
    tetrahedron, they are discarded and not checked. This is the
    default, except in the grid module.

  - 3 : 'qtree gradient'. This method behaves much like the 'full
    gradient', but whenever the gradient path steps near a grid
    point, it is projected to it. When a projection occurs, the grid
    point is pushed into a stack. At the end of the gradient path,
    when the terminus is known, all the grid points in the stack are
    popped and assigned the terminus.

    The projection regions are spheres located around each grid
    point, whose radius is controlled by the QTREEFAC keyword. The
    radius of these spheres is minlen / 2**qtreelvl / qtreefac ,
    where minlen is the smallest edge length of the full set of IWST
    and qtreelvl is the maximum subdivision level. Note that
    QTREEFAC equals 1 is the maximum value allowed, and corresponds
    to touching spheres along, at least, one tetrahedron edge. By
    default, QTREEFAC is 2, that is a compromise value. Lower levels
    of QTREEFAC tend to give errors when assigning the grid points
    that lie on the IAS of two atoms (although *only* there). With
    higher levels, the time saving is gone, and 'qtree gradient'
    reduces to 'full gradient'.

    Additionally, the projection can be started only after a certain
    number of initial steps. The MPSTEP keyword controls this value,
    and defaults to 0.

  - -1, -2, -3: these correspond to the same as their positive
    values, but each gradient path terminus is compared to their
    'full gradient' version, using the best available ODE
    integration method. Information about the results of the
    comparison is output to stdout, and a .tess file is generated
    (difftermxx.tess, where xx is the subdivision level) containing
    the position of the points where both termini differ.

  If the integration region is not periodic, then methods 'color'
  and 'qtree' are not defined. There are two possible options,
  controlled by the 'KILLEXT' and 'NOKILLEXT' keywords. If KILLEXT
  is active (the default behavior), the gradient path tracing is
  killed whenever it leaves the integration region, independently of
  the GRADIENT_MODE being used. The terminus is then assigned to an
  'unknown' state, and the tetrahedra it generates are not
  integrated. If NOKILLEXT is active, the gradient path is continued
  as a 'full gradient', until the terminus is found.

  The default is KILLEXT because, if the integration region is not
  periodic, the integral over atoms that are partially contained in
  it is most likely not meaningful to the user.

  The ODE integration method can be chosen using the QTREE_ODE_MODE
  keyword, that can assume the following values:

  - 1 : Euler method, fixed step, 1st order.

  - 2 : Heun method, fixed step, 2nd order.

  - 3 : Kutta method, fixed step, 3rd order.

  - 4 : Runge-Kutta method, fixed step, 4th order.

  - 5 : Euler-Heun embedded method, adaptive step. 1st order with
    2nd order error estimation. 2 evaluations per step.

  - 6 : Bogacki-Shampine embedded method, adaptive step. 3rd order
    with 5th order error estimation. The FSAL (first step also
    last) allows only 4 evaluations per step. Local
    extrapolation.

  - 7 : Runge-Kutta Cash-Karp embedded method, adaptive step. 4th
    order with 5th order error estimation. 6 evaluations per
    step.

  - 8 : Dormand-Prince 4-5 embedded method, adaptive step. 4th order
    with 5th order error estimation. 6 evaluation per step, with
    FSAL. Local extrapolation.

  For embedded methods (4--8), the absolute error requested to the
  method can be set using the ODE_ABSERR keyword. The default of
  this variable is chosen so that reasonable stepsizes are
  kept. This default is 1d-3 for Euler-Heun and 1d-4 for the rest.
  Note that it makes no sense an equivalent ODE_RELERR keyword.

  Experimentally, using a method with n more evaluations is better
  than reducing the step size of the lower accuracy method n
  times. Additionally, there is no upper limit to the step size
  (I am assuming nobody is going to use ODE_ABSERR = 1d2), so
  methods with greater accuracy (7 and 8) save evaluations by
  increasing stepsize to values much larger than their lower
  accuracy counterparts.

  The step size of the fixed step methods (1--4) is controlled with
  the STEPSIZE keyword (bohr). In the variable step methods (5--8) the
  value of STEPSIZE is used as the starting step.

  The default QTREE_ODE_MODE is Dormand-Prince (8).

* When the integration of the base tetrahedron is finished, the
  termini of the grid points located at each one of its four faces
  are copied to the corresponding neighboring IWST using the
  information found in section 3. Of course, this is only done if
  DOCONTACTS is active.

* Once the integration of the IWST is completed, the atomic
  properties are scaled and summed to the integrals inside the
  beta-spheres. The final result is output, together with an
  analysis of the contribution of each subdivision level to the
  total integrated properties.

* It is possible to plot the basins obtained by QTREE using the
  PLOT_MODE keyword. It can assume the values:

  - 0 : no plotting is done.

  - 1 : a single tess file is written containing a description of
    the unit cell CPs, the IWS, and balls corresponding to all the
    grid points that have been sampled.

  - 2 : same as 1 but only the balls that are either on the face of
    an IWST or close to a IAS are output.

  - 3 : the full WS cell

  - 4 : a file for the full WS cell and several files, containing a
    description of each of the integrated basins. Note that the
    basins need not be connected.

  - 5 : same as 4 but only balls belonging to faces of IWST and IAS
    are output.

  The default value is 0. If PLOT_MODE is > 0, then it is possible
  (and it is active by default) to plot the sticks that form the
  tetrahedra inside .stick files. The PLOTSTICKS and NOPLOTSTICKS
  keywords control this behaviour.

Some additional considerations:

* The integration of the volume is not done using the beta-sphere /
  basin separation because the volume of each tetrahedron is exactly
  known. This implies that the integrated cell volume for a periodic
  integration region will always be exact (if it is not, then it is an
  error). The integrated cell charge, on the contrary, is a measure of
  how well the tetrahedra are being integrated, but *not* of how well
  the IAS is being determined.

* For very high levels of QTREE (say 10--11, depending on the amount
  of memory your computer has), memory usage may turn out to be a
  problem. The COLOR_ALLOCATE keyword controls the amount of memory
  allocated for the color and property arrays. The syntax is:
~~~
COLOR_ALLOCATE {0|1}
~~~
  Using a zero value, the color vector (and possibly the properties
  vectors, depending on PROP_MODE) is allocated only for the current
  IWST. This saves memory but makes the computation slower, specially
  if the GRADIENT_MODE is 2 or 3. In addition, setting COLOR_ALLOCATE
  to 0 deactivates the passing of colors through the contacts
  (DOCONTACTS and NOCONTACTS keywords) and the plotting (sets
  PLOT_MODE to 0). If COLOR_ALLOCATE is 1, the color (and optionally
  the properties) of all the IWST are saved. By default,
  COLOR_ALLOCATE is 1 if maxlevel.i <= 8 and 0 if the maximum level is
  higher.

QTREE is described in J. Comput. Chem. 32 (2010) 291-305. Please, cite
this reference if you use this keyword in your work.

### Yu and Trinkle (YT)

~~~
YT [NNM] [NOATOMS] [WCUBE] [BASINS [OBJ|PLY|OFF] [ibasin.i]] [RATOM ratom.r]
   [DISCARD expr.s]
~~~
The Yu-Trinkle (YT) algorithm uses the reference field to calculate
the attraction basins. The reference field must be defined on a
grid. Hence it won't work directly with wien2k, elk or aiPI densities,
but those can be transformed into a grid by appropriate use of the
LOAD keyword. The algorithm proceeds by running over grid nodes in
decreasing order of density. If a point has no neighboring points with
higher density, then it's a local maximum. If it does, but all of them
belong to the same basin then it belongs to the interior of that basin
as well. Otherwise, it is sitting on top of the interatomic
surface. The actual fraction of a grid point on a IAS belonging to a
particular basin is calculated by evaluating the trajectory flow to
neighboring points.

The YT algorithm is described in J. Chem. Phys. 134 (2011) 064111
which should be consulted for further details. Please, cite this
reference if you use this keyword in your work.

The located maxima are identified by default with the closest
nucleus. If non-nuclear maxima are expected, use the NNM keyword to
assign only maxima that are only within 1 bohr of the closest atom.
This distance can be changed using the RATOM keyword (ratom.r in bohr
(crystals) or angstrom (molecules)), which also controls the distance
between two maxima to be considered equal. Changing the default
ratom.r using the RATOM keyword automatically activates the detection
of NNM. The NOATOMS option is appropriate for scalar fields where the
maxima are not expected to be at the atomic positions (or at least not
all of them). If NOATOMS is used, all the maxima found are given as
NNM. This is useful for fields such as the ELF, the Laplacian,
etc.

The WCUBE option makes critic2 write cube files for the integration
weights of each attractor. In YT, these weights are values zero
(outisde the basin), one (inside the basin), or some intermediate
value near the atomic basin boundary. The generated cube files have
names <root>_wcube_xx.cube, where xx is the attractor number.

Use the BASINS option to write a graphical representation of the
calculated basins. The format can be chosen using the OBJ, PLY, and
OFF keywords (default: OBJ). If an integer is given after the format
selector (ibasin.i), then plot only the basin for that
attractor. Otherwise, plot all of them. The basin surfaces are colored
by the value of the reference field, in the default gnuplot scale.

Any maxima that is not assigned to an existing atom or non-nuclear
critical point is automatically added to the critical point list, see
`Finding critical points`_. It is possible to get more information
about these maxima by using the CPREPORT keyword, see `Requesting more
information about the critical point list (CPREPORT)`_. 

In some cases, particularly if there is a vacuum region in your system
(or your system is a molecule), multiple spurious maxima will appear
due to numerical noise in the grid values. The number of spurious
attractors will increase the computational cost and serve little
purpose, as the vacuum region will integrate to zero anyway. In these
cases, the DISCARD keyword can be used to make critic2 ignore any
attractor that matches the expression expr.s when it is evaluated at
that point. For instance, if the electron density is given by field
$rho, and we want to discard low-density critical points, we could use
DISCARD "$rho < 1e-7". The arithmetic expression can involve any
number of fields, not just the reference field.

Not all the properties defined by the INTEGRABLE keyword are
integrated. Only the subset of those properties that are grids, have F
or FVAL as the integrand and are congruent with the reference grid are
considered. This limitation can be circumvented by using LOAD AS. In
addition, no core is used even if the CORE keyword is active. The
volume is always integrated. A xyz file (<root>_yt.xyz) is always
written, containing the unit cell description (with border, see WRITE)
and the position of the maxima, labeled as XX.

Note that in the output ('List of basins and local properties'),
'Charge' refers not to the integrated electron density (because
critic2 doesn't know what is an electron density and what not) but to
the value of the integral of the reference field in its own basins
(which may not make much sense if you are integrating, for instance,
the ELF or the Laplacian). Loading a second field and using INTEGRABLE
and the field number is the way to go in such cases.

Usage of the YT algorithm for grid fields is strongly recommended, as
it is much more efficient, robust and accurate than the other
alternatives. BADER is, however, more memory-efficient than YT, so it
is recommended for very large grids instead.

### Henkelman et al. method (BADER)

The algorithm by Henkelman et al. uses the BADER keyword:

~~~
BADER [NNM] [NOATOMS] [WCUBE] [BASINS [OBJ|PLY|OFF] [ibasin.i]] [RATOM ratom.r]
      [DISCARD expr.s]
~~~
The BADER algorithm uses the reference field to calculate the basins;
this field must be defined on a grid. BADER assigns grid nodes to
basins using the near-grid method incrementally described in
Comput. Mater. Sci. 36, 254-360 (2006), J. Comput. Chem. 28, 899-908
(2007), and J. Phys.: Condens. Matter 21, 084204 (2009). Please, cite
these references if you use this method.

The output and the option keywords have the same meaning as YT. Using
BADER as an alternative to YT is recommended in very large grids
because its more efficient memory usage. The weight cubes written by
WCUBE contain zeros for the grid points outside the basin, and ones
inside. 

## Non-covalent interaction visualization (NCIPLOT)

~
NCIPLOT
  ONAME root.s
  CUTOFFS rhocut.r dimcut.r
  RHOPARAM rhoparam.r
  RHOPARAM2 rhoparam2.r
  CUTPLOT rhoplot.r dimplot.r
  SRHORANGE srhomin.r srhomax.r
  VOID void.r
  RTHRES rthres.r
  INCREMENTS x.r y.r z.r
  NSTEP nx.i ny.i nz.i
  ONLYNEG
  NOCHK
  CUBE x0.r y0.r z0.r x1.r y1.r z1.r
  CUBE file1.xyz file2.xyz ...
  MOLMOTIF
  FRAGMENT file.xyz
  FRAGMENT
   x.r y.r z.r # (in angstrom!)
   ...
  ENDFRAGMENT/END
ENDNCIPLOT/END
~~~
Calculates the density and reduced density gradient on a cube for the
visualization of non-covalent interactions. The output files are

* `<root>.dat`: a 2-column file with reduced density gradient (col. 2)
  vs. density (col. 1) calculated at the points of a grid. The density
  in column one is multiplied by the sign of the second eigenvalue of
  the density Hessian.

* `<root>-dens.cube`: a cube containing the electron density times the
  sign of the second Hessian eigenvalue times 100.

* `<root>-grad.cube`: a cube containing the reduced density gradient
  (RDG).

* `<root>.vmd`: the VMD script for convenient visualization of the
  results.

The root of the files can be changed using the ONAME keyword (default:
`<root>`).

By default, the region represented is the whole unit cell, with step
lengths of 0.1 bohr in each direction. The step lengths or the number
of points in each axis can be controlled with the keywords:
~~~
INCREMENTS x.r y.r z.r
~~~
x.r, y.r and z.r are the step lengths in each direction in bohr
(crystals) or angstrom(molecules).
~~~
NSTEP nx.i ny.i nz.i
~~~
NSTEP defines the number of steps in each direction.

If plotting the whole unit cell is not convenient, a parallelepipedic
region can be extruded from the crystal with the keyword:
~~~
CUBE x0.r y0.r z0.r x1.r y1.r z1.r
~~~
where (x0.r y0.r z0.r) and (x1.r y1.r z1.r) are the cube limits in
crystallographic coordinates (crystals) or molecular Cartesian
coordinates (molecules, default unit: angstrom). In crystals, a region
larger than one periodic cell can also be selected with this
method. In addition, it is possible to define the cube containing a
fragment of the structure using:
~~~
CUBE file1.xyz file2.xyz ...
~~~
Define the limits of the cube using the crystal fragments contained in
file1.xyz, file2.xyz,... A small border (RTHRES) is added around the
region exactly containing all the atoms. The xyz files have the usual
xyz format (in angstrom), in the same spirit as the FRAGMENT
keyword. The xyz, however, are not used as fragments for the NCI
calculation.

Some cutoffs are relevant to the visualization of the NCI:
~~~
CUTOFFS rhocut.r dimcut.r
~~~
These cutoffs apply to the writing of density and reduced density
gradients (respectively) to the dat file. If, at a given point, the
density is above rhocut.r or the reduced density gradient is above
dimcut.r, then the point is not written to the dat file. Defaults:
rhocut.r = 0.2 and dimcut.r = 2.0 for loaded densities and 1.0 for
promolecular densities.
~~~
CUTPLOT rhoplot.r dimplot.r
~~~
When the density is greater than rhoplot.r, the rdg in the -grad.cube
file is set to 100d0, effectively eliminating the point from the
isosurface plot. Also, the color scale represented in RDG isosurfaces
ranges from -rhoplot.r to rhoplot.r. The default value is 0.05
(selfconsistent densities) or 0.07 (promolecular). The dimplot.r
controls the isosurface value to be represented in VMD. Default: 0.5
(SC) or 0.3 (promolecular).
~~~
SRHORANGE srhomin.r srhomax.r
~~~
Similar to CUTPLOT. When the density times the sign of the second
Hessian eigenvalue is greater than srhomax.r or smaller than
srhomin.r, the rdg in the -grad.cube file is set to 100d0, effectively
eliminating the point from the isosurface plot. This is useful when
plotting a subset of the peaks found in the dat file as
isosurfaces. Default: no range used.
~~~
MOLMOTIF
~~~
Complete the molecules that lie across unit cell faces by using atoms
in the neighboring cells.
~~~
ONLYNEG
~~~
Represent only the points where the second eigenvalue of the Hessian
is negative.
~~~
NOCHK
~~~
Do not read or write the checkpoint file. The nciplot checkpoint file
(<root>.chk_nci) contains the promolecular densities for the whole
system and the fragments, the density, and the reduced density
gradient. If the checkpoint file exists and is compatible with the
current structure and fragments, it is read. Otherwise, it is
discarded and a new checkpoint is written. By default, checkpoitn
files are used unless NOCHK is given in the input.
~~~
VOID void.r
~~~
Represent only the points where the promolecular density is lower than
void.r.
~~~
FRAGMENT file.xyz
FRAGMENT
 x.r y.r z.r # (in angstrom!)
 ...
ENDFRAGMENT/END
~~~
In the current version of NCIplot it is possible to define molecular
fragments in order to focus on some part of the crystal, or some
particular interaction. This is done by using the FRAGMENT
environments. Each FRAGMENT block defines one fragment and only the
intermolecular interactions between fragments are represented (hence,
you need at least two blocks). The atomic positions (in Cartesian
coordinates, the units are angstrom) of the atoms in the fragment
appear inside. To obtain the list of atoms, the recommended
procedure is to write an xyz file (using the WRITE keyword), then
cutting it into pieces (using, for instance, avogadro) and then
placing the resulting atom lists in FRAGMENT environments.

Alternatively, the fragment can be read from an xyz file.

There are three options that control the behavior of the fragments:
RTHRES, RHOPARAM and RHOPARAM2.
~~~
RTHRES rthres.r
~~~
When fragments are used, the density and rdg grids are reduced to
a piece encompassing the fragments, with a border of rthres.r (bohr in
crsytals, angstrom in molecules, default: 2.0 bohr).
~~~
RHOPARAM rhoparam.r
~~~
Consider only the points where none of the fragments contributes
more than rhoparam.r times the total promolecular density (default:
0.95).
~~~
RHOPARAM2 rhoparam2.r
~~~
Consider only the points where the sum of the density of all
fragments is more than rhoparam2.r times the total promolecular
density (default: 0.75). Note that the fragments need not include
all atoms in the crystal.

Some advice regarding the execution of NCIPLOT:

* If the density is given on a grid, it is usually much faster if
  core-augmentation (ZPSP and the CORE field option) is not used. The
  reason is that if the core augmentation is not present, the reduced
  density gradient and the Hessian components can be calculated by
  Fourier transform (which is smoother) and it is not necessary to sum
  over neighboring atoms. However, not using the core augmentation can
  sometimes result in noisy Hessian components, which may result in
  alternate blue/red domains (because of a spurious change of sign
  caused by numerical inaccuracies).

* Likewise, any option that activates the calculation of the
  promolecular density (VOID or FRAGMENT) is going to be expensive
  because it involves a sum over neighboring atoms. In those cases, it
  is recommended to calculate the promolecular density once for a
  certain grid, then use the checkpoint file.

* Some programs (most notably older versions of VMD) have problems
  dealing with non-orthogonal cells. There's little critic2 can do
  about this - the cube files on output hav been examined and they
  seem to be correctly written. Using FRAGMENT or CUBE in critic2 so
  that a orthogonal piece of the crystal is represented may help.

## Structural tools

### Relabel the atoms in the structure (ATOMLABEL)

~~~
ATOMLABEL template.s
~~~
The ATOMLABEL keyword can be used to change the atomic labels for the
atoms in the current structure. The template string (template.s) is
used to build the new atomic names. The format specifiers for this
template are:

* %aid : the index for the atom in the non-equivalent atom list. 

* %id : the index for the atom in the non-equivalent atom list,
   counting only the atoms of the same type.

* %S : the atomic symbol, derived from the current atomic number.

* %s : same as %S, but lowercase.

* %l : the current atom label.

### Powder diffraction (POWDER)

~~~
POWDER [TH2INI t2i.r] [TH2END t2e.r] [{L|LAMBDA} l.r]
       [FPOL fpol.r] [NPTS npts.i] [SIGMA sigma.r]
       [ROOT root.s]
~~~
Generate the powder diffraction pattern for the current crystal
structure. Consider only the 2*theta range going from t2i.r
(default: 5 degrees) to t2e.r (def: 90). The wavelength of the
incident radiation is given by l.r (in angstrom). The polarization
of the x-ray radiation affects the treatment of the resulting
intensities. The default is fpol.r = 0, corresponding to unpolarized
light. For synchrotron radiation, use fpol.r = 0.95. npts.i is the
number of points in the generated spectrum. Gaussian broadening is
used on the observed peaks, with width parameter sigma.r (def:
0.05). By default, two files are generated: <root>_xrd.dat,
containing the 2*theta versus intensity data, and <root>_xrd.gnu,
the gnuplot script to plot it. The name of these files can be
changed using the ROOT keyword.

### Radial distribution function (RDF)

~~~
RDF [REND t2e.r] [SIGMA sigma.r] [NPTS npts.i] [ROOT root.s]
~~~
Generate the radial distribution function (RDF) for the current
structure. The definition is similar to the one found in Willighagen
et al., Acta Cryst. B 61 (2005) 29, but where the atomic charges are
replaced by the square root of the atomic number. The RDF is plotted
up to a maximum distance t2e.r bohr (default: 25 bohr) using npts.i
points in that interval (default: 10001). Gaussian broadening is used
with sigma equal to sigma.r (default: 0.05). Two files are generated:
`<root>_rdf.dat`, containing the rdf versus distance data, and
`<root>_rdf.gnu`, the gnuplot script to plot it. The name of these files
can be changed using the ROOT keyword.

### Compare crystal structures (COMPARE)

~~~
COMPARE [MOLECULE|CRYSTAL] [SORTED|UNSORTED] [XEND xend.r] 
        [SIGMA sigma.r] [POWDER|RDF] 
        {.|file1.s} {.|file2.s} [{.|file3.s} ...]
~~~
Compare two or more structures. If the structures are crystals, find
the measure of similarity (DIFF) based on either their radial
distribution functions (RDF keyword) or their powder diffraction
patterns (POWDER). If they are molecules, all atoms may come in the
same order (SORTED) or not (UNSORTED, default). If they do, find the
translation and rotation that brings the two molecules into closest
agreement and report the root-mean-square (RMS) of the atomic
positions. If the atoms are unsorted, compare the molecules using the
radial distribution functions.

In crystals, the default is to use the powder diffraction
patterns. Two crystal structures are exactly equal if DIFF =
0. Maximum dissimilarity occurs when DIFF = 1.  The crystal similarity
measure is calculated using the cross-correlation functions defined in
de Gelder et al., J. Comput. Chem., 22 (2001) 273, using the triangle
weight. Powder diffraction patterns are calculated from 2theta = 5 up
to xend.r (default: 50). Radial distribution functions are calculated
from zero up to xend.r bohr (default: 25 bohr). SIGMA is the Gaussian
broadening parameter for the powder diffraction or RDF peaks.  The RDF
defaults also apply to comparison of unsorted molecules.

In sorted molecules, the root mean square (RMS) of the atomic
positions is reported (the units are angstrom, unless changed with the
UNITS keyword). The molecular rotation is calculated using Walker et
al.'s quaternion algorithm (Walker et al., CVGIP-Imag. Understan. 54
(1991) 358). For the comparison to work correctly, it is necessary
that the two molecules have the same number of atoms and that the
atoms are in the same sequence.

Whether the molecular or the crystal comparison is used depends on the
file formats passed to COMPARE. If the MOLECULE/CRYSTAL keyword is
used then the molecule/crystal comparison code is used.

The structures can be given by passing an external file to
COMPARE. The syntax is the same as in CRYSTAL and MOLECULE: the file
format is identified using the file extension. If a dot (".") is used
instead of a file name, use the current structure (previously loaded
with CRYSTAL/MOLECULE).

The COMPARE keyword does not require a previous CRYSTAL or MOLECULE
keyword. Hence, valid critic2 inputs would be:
~~~
CRYSTAL bleh1.scf.in bleh2.cif
MOLECULE bleh1.xyz bleh2.wfx
~~~
provided the files exist.

### Other structural tools (NEWCELL, ENVIRON, PACKING, IDENTIFY, EWALD)

~~~
NEWCELL {x1.r y1.r z1.r x2.r y2.r z2.r x3.r y3.r z3.r|n1.i n2.i n3.i}
        [INV|INVERSE] [ORIGIN x0.r y0.r z0.r]
NEWCELL [PRIMSTD|STANDARD|PRIMITIVE|NIGGLI|DELAUNAY]
~~~
Transform the crystal structure description by using a new unit cell
given by the vectors x1, x2, x3 (in crystallographic coordinates)
relative to the old unit cell. The x1, x2, x3 vectors must be pure
translations of the old cell; either lattice vectors, centering
vectors, or combinations of the two. Alternatively, if three integers
are given (n1.i n2.i n3.i) build a supercell with n1.i cells in the a
direction, etc. 

NEWCELL unloads all fields (except the promolecular density) and
clears the critical point list. If the INV (or INVERSE) keyword is
used, the input vectors correspond to the crystallographic coordinates
of the old cell in the new coordinate system. Optionally, if an ORIGIN
vector is given, the cell origin is translated to x0, which should be
given in the coordinates of the original cell.

The NEWCELL keyword is useful for building supercells or for
performing routine but tedious crystallographic transformations. For
instance, given a face-centered cubic lattice and the conventional
cubic cell one can find the primitive (rhombohedral) cell by doing:

~~~
CRYSTAL LIBRARY mgo
NEWCELL 1/2 1/2 0 1/2 0 1/2 0 1/2 1/2
~~~
Likewise, if the current cell is rhombohedral, the same NEWCELL order
but including the INVERSE keyword transforms to the cubic. That is:

~~~
CRYSTAL LIBRARY mgo
NEWCELL 1/2 1/2 0 1/2 0 1/2 0 1/2 1/2
NEWCELL 1/2 1/2 0 1/2 0 1/2 0 1/2 1/2 INVERSE
~~~
gives a unit cell and crystal structure description that is equivalent
to the initial one read from the library.

NEWCELL also admits specific keywords. The cell can be transformed to: 

* STANDARD: standard unit cell. 

* PRIMITIVE: standard primitive unit cell. Do not transform if the
  unit cell is already primitive.

* PRIMSTD: standard primitive unit cell. Do the transformation even if
  the current unit cell is primitive.

* NIGGLI: Niggli-reduced cell for the current lattice. Use a NEWCELL
  PRIMITIVE first to get the primitive Niggli cell.

* DELAUNAY: Delaunay-reduced cell for the current lattice. Use a
  NEWCELL PRIMITIVE first to get the primitive Delaunay cell.

The origin is not translated in any of these keywords. See the spglib
manual for more information.

~~~
ENVIRON [DIST dist.r] [POINT x0.r y0.r z0.r|ATOM at.s/iat.i]
[BY by.s/iby.i] [SHELLS]
~~~
Print list of neighbor atoms. If POINT is given, print the neighbors
around the point with coordinates x0.r y0.r z0.r in crystallographic
coordinates (crystal) or or molecular Cartesian coordinates (moelcule,
default units: angstrom). If ATOM is given, print the neighbors around
atom iat.i from the non-equivalent atom list or around every atom with
atomic symbol at.s (converted internally to atomic number). If neither
POINT nor ATOM are given, print the environments of all non-equivalent
atoms in the unit cell.

By default, the environments extend up to 5 angstrom from the central
point. The DIST keyword can be used to change this value (by default,
dist.r is in bohr in crystals and angstrom in molecules). The BY
keyword allows filtering the neighbor list to print only certain kinds
of atoms. If iby.i is given, print only atoms whose non-equivalent ID
is the same as iby.i. If by.s is given, print only atoms with the same
atomic symbol as by.s (converted internally to atomic number). If
SHELLS is given, group the neighbors in shells by distance (1e-2
atomic distance threshold) and non-equivalent ID.

~~~
COORD [DIST dist.r] [FAC fac.r] [RADII {at1.s|z1.i} r1.s [{at2.s|z2.i} r2.s ...]]
~~~
Calculate the pair and triplet coordination numbers in the crystal or
molecular structure. By default two atoms are coordinated if they are
within fac.r times the sum of their radii. By default, fac.r is equal
to the BONDFACTOR and the covalent radii are used (see the BONDFACTOR
and RADII keywords in `Control commands and options`_). The value of
fac.r can be changed with the FAC keyword. The atomic radii for atomic
species can be changed with RADII, either by giving the atomic symbol
(at1.s) or the atomic number (z1.i) followed by the new radius
(default: bohr in crystals and angstrom in molecules). If the DIST
keyword is used, all atoms within a distance dist.r are coordinated.

On output, COORD will list the number of coordinated pairs per atom in
the unit cell and per atomic species. In addition, it will also list
all coordinated triplets X-Y-Z, where Y runs over all atoms in the
unit cell and over all atomic species.

~~~
PACKING [VDW] [PREC prec.r]
~~~
Compute the packing ratio assuming atomic spheres with radius equal to
the nearest neighbor distance divided by 2. If VDW is used, then use
the van der Waals radii and allow the spheres to overlap. This option
is currently implemented by building a grid on the unit cell and
checking whether its points are inside any atomic sphere, which is not
very efficient. The PREC allows controlling the precision of the
packing ratio calculated using the VDW keyword. If PREC is used,
expect an error in the percent packing ratio in the order of
prec.r. The default prec.r is 0.1.

~~~
IDENTIFY [ANG|ANGSTROM|BOHR|AU|CRYST|file.xyz]
 x.r y.r z.r [ANG|ANGSTROM|BOHR|AU|CRYST]
 ...
 file.xyz
ENDIDENTIFY/END
~~~
Identify the coordinates in the input and match them against the list
of atoms and critical points. If a coordinate is close (1e-4 bohr) to
an atom or CP, the corresponding indices as well as the coordinates
are written to the output. The input can come as either the
coordinates of the points themselves or a filename pointing to an xyz
file. IDENTIFY can be used as in environment mode
(IDENTIFY/ENDIDENTIFY) or as a single command when applying it to a
single xyz file.

The default units are crystallographic coordinates in crystals and
molecular Cartesian coordinates in molecules (default:
angstrom). However, they can be modified with one of the keywords that
follow IDENTIFY. For specific points, the unit can be changed by
specifying a keyword after the three coordinates. The units in the xyz
file are angstrom (the xyz file has to have the usual syntax, with the
number of atoms in the first line and the title in the second line).

In addition, critic2 provides the vertices of the cube that
encompasses all the points in the list that did match an atom or CP.

~~~
EWALD
~~~
Calculate the electrostatic energy of the lattice of point charges
using Ewald's method. The atomic charges are defined using the Q
keyword.

## Scanning Tunneling Microscopy plots (STM)

~~~
STM [CURRENT [curr.r]|HEIGHT [hei.r]] [TOP top.r]
    [{CELL|CELLS} nx.i ny.i] [NPTS n1.i n2.i]
    [LINE x0.r y0.r x1.r y1.r npts.i]
~~~
Generate an STM plot for the current system, comparable to those
obtained in actual STM experiments. The STM keyword should be applied
only to systems meeting the following requirements:

* The geoemtry is a slab, possibly with molecules adsorbed to one or
  both faces.

* The slab and the corresponding vacuum are perpendicular to one of
  the crystallographic axes (a, b, or c). The two angles related to
  the perpendicular axis must be right. For instance, a typical
  situation is one where a and b form a hexagonal cell in the plane,
  and c is perpendicular to the slab. The angles related to c (alpha
  and beta) both are 90 degrees.

* The slab has two faces: one with vacuum above and one below. Only
  the face with vacuum above it will be used.

* The STM plot calculation uses the reference field. For results
  consistent with the Tersoff-Hamann approximation, the reference
  field should be the local density of states (LDOS, in the following)
  at the Fermi level, that is, the density generated by the Kohn-Sham
  states close to Ef. This field can be obtained easily from common
  condensed-matter electronic structure programs. For instance, in QE,
  one would use plot_num 3 or 5 in pp.x.

There are two modes of operation in the STM keyword. In the default
mode (CURRENT), the plot gives the height (in angstrom) for which the
LDOS equals curr.r (a.u. units, default: 1d-3). This corresponds to
the constant-current mode in STM experiments. The other mode is
HEIGHT, in which the LDOS at a constant height over the surface is
plotted. This is the constant-height mode in STM experiments. The
hei.r option to HEIGHT is the fractional coordinate along the
perpendicular axis of the plot plane. By default, critic2 uses the
fractional coordinate corresponding to the last atom before the
vacuum.

The CURRENT plot shows the distance in angstrom with respect to a
point that also corresponds to the last atom before the vacuum. In
the case of a surface with adsorbed molecules on it, this is not very
useful; usually one wants to refer this value to the top of the slab
surface. The TOP keyword allows changing this value. top.r is the
fractional coordinate along the perpendicular axis that will be used
as reference for the CURRENT plot.

The CELL (or CELLS) keyword controls the number of unit cells plotted
in each in-plane crystallographic direction (default: 1 1). The number
of points plotted in each in-plane unit cell is given by the NPTS
keyword (n1.i and n2.i). By default, critic2 uses 51x51 points or, if
the reference field is a grid, the number of grid points in each of
those directions. If a grid is used, letting critic2 use the grid
geometry is strongly recommended because it is more time-efficient and
accurate.

On output, two files will be written. The <root>_stm.dat file contains
the 2D data for the STM signal on the selected plane. The
`<root>_stm.gnu` file is an example script that generates a plot similar
to those found in the literature.

The LINE keyword makes critic2 plot a line instead of a plane. The
line goes from (x0,y0) to (x1,y1), in fractional coordinates for the
in-plane crystallographic axes. npts.i points along the line are
calculated. The output file is `<root>_stm_line.dat`.

The current implementation of STM has benefited from the code and the
guidance kindly provided by Enrico Benassi (see THANKS).

## Miscellaneous commands

### Molecular calculations (MOLCALC)

~~~
MOLCALC [NELEC]
MOLCALC PEACH
  mo1a [->] mo1r k1
  mo2a [->] mo2r k2
  [...]
ENDMOLCALC/END
MOLCALC expr.s
MOLCALC HF
~~~
This keyword allows the calculation of molecular quantities. Mostly
using molecular wavefunction (wfn/wfx/fchk/molden) fields and
Becke-style grids, but crystals can also be used.

The NELEC keyword integrates the number of electrons. This is useful
for debugging purposes.

If an expression (expr.s) is used, the scalar field generated by it is
integrated in the molecular mesh.

The PEACH keyword calculates the index for the characterization of
electronic excitations based on orbital overlap defined as uppercase
lambda in Peach et al., J. Chem. Phys. 128 (2008) 044118. Small values
(close to zero) correspond to little orbital overlap and Rydberg
excitations. Large values (close to one) are caused by high orbital
overlap and correspond to local excitations. Charge transfer
excitations can have both high or low PEACH value. Each line gives the
initial (mo1a) and final (mo1r) molecular orbital and the oscillator
strength (k1) for each component of the excitation. If Gaussian is
used, copying and pasting the output of the TD keyword is
recommended. Using the PEACH keyword requires the virtual orbitals,
which in turn requires using a fchk or molden file format with the
READVIRTUAL keyword (see `Loading a field (LOAD)`_).

MOLCALC HF calculates the Hartree-Fock energy from the basis set
information in the reference field using molecular integrals, which
are in turn calculated by the libCINT library. Using this keyword
requires compiling with critic2 with libCINT (see the README). At this
moment, this keyword serves mostly for testing, debug, and development
purposes, as it is very inefficient. The routine called by this
keyword shows how to use libCINT inside critic. Only molecular
wavefunctions can be used with MOLCALC HF and only file formats that
provied basis set information (right now, only Gaussian fchk, but
molden-style files could be implemented). Gaussian wfn/wfx do not
provide basis set shells, only primitives, so they cannot be used with
MOLCALC HF.

### Hirshfeld charges (HIRSHFELD)

~~~
HIRSHFELD
~~~
Calculate the Hirshfeld charges. Only for fields on a grid.

### The exchange-hole dipole moment (XDM) model of dispersion

The XDM module calculates the dispersion energy using the
exchange-hole dipole moment (XDM) model. See J. Chem. Phys. 127,
154108 (2007), J. Chem. Phys. 136, 174109 (2012), and
J. Chem. Phys. 138, 204109 (2013) for more details.

~~~
XDM GRID [RHO irho.s] [TAU itau.s] [ELF ielf.s] 
    [PDENS ipdens.s] [CORE icor.s] [LAP ilap.s] 
    [GRAD igrad.s] [RHOAE irhoae.s] [XB ib.s] 
    [XA1 a1.r] [XA2 a2.r] [ONLYC] [UPTO {6|8|10}]
XDM QE [BETWEEN at1.i at1.i ... AND at1.i at2.i ...]
XDM a1.r a2.r chf.s
~~~
There are three modes for the XDM keyword. In QE, the coefficients are
read from a Quantum ESPRESSO output (loaded using CRYSTAL), and the
XDM energy is recalculated. If BETWEEN and AND are given only the
dispersion interaction between those pairs of atoms is calculated.
This keyword is used mostly for testing purposes. In GRID, the
information necessary to calculate the XDM dispersion energy and
related quantities is provided using grid fields. Otherwise, a
molecular XDM calculation is assumed, with damping function
coefficients a1.r and a2.r and functional selector chf.s. The latter
can be either a keyword for a functional (blyp, b3lyp, etc.) or a
number between 0 and 1 indicating the fraction of exact exchange. The
molecular XDM code can be used only with wavefunction fields and DFTB
fields.

The rest of the information in this section applies to the XDM GRID
keyword. 

XDM uses the electron density (RHO), the kinetic energy density (TAU),
the Laplacian (LAP), and the gradient of the electron density (GRAD)
to compute the exchange-hole dipole moment in the Becke-Roussel model
(B). The promolecular density (PDENS) and the core density (CORE) are
used to calculate a Hirshfeld partitioning of the unit cell. All of
these fields have to be available or are calculated when running
XDM. The corresponding keywords accept an integer, corresponding to a
previously LOADed field. During the XDM run, cubes for all of these
fields are generated so they can be loaded in subsequent runs. Note
that the PDENS cube is the same as generated in NCIPLOT (except for
changes in size).

The list of requierements is:

* RHO: the electron density. By default, irho.s is the reference
  field. This field is required in XDM. It is also required to give
  the pseudopotential charges using the ZPSP keyword for all types of
  atoms in the system.

* TAU: the kinetic energy density. It is used in the calculation of B,
  and can be extracted from the ELF. Hence, it is required except if
  the ELF or the B is given. If the ELF is used instead of TAU, a cube
  file (-tau.cube) is written.

* ELF: the electron localization function. Can be used in place of
  TAU. This is useful because most programs (e.g. QE, VASP) generate
  cubes for the ELF but not for the kinetic energy density.

* PDENS: the promolecular density. It is generated by critic2 if not
  present in the XDM call, and written to a cube file (-pdens.cube)
  for future use.

* CORE: the core density. It is generated by critic2 if not present in
  the XDM call and written to a cube (-core.cube), unless the B and
  RHOAE are given, in which case it is ignored. The ZPSP of all atoms
  is required in order to calculate this quantity.

* LAP: the Laplacian of the electron density. It is generated by
  Fourier transform of RHO unless it is given or B is given, in which
  case it is not needed and its calculation is skipped.

* GRAD: the gradient of the electron density. It is generated from RHO
  unless B is given. If B is available, the calculation of GRAD is
  skipped.

* RHOAE: the all-electron density on a cube. If given, replaces the
  pseudo-density plus core in the calculation of the atomic volumes.

* XB: the exchange-hole dipole moment in the Becke-Roussel
  model. Calculated from the above unless given.

The usual way of running XDM for the first time is:

~~~
CRYSTAL rho.cube
ZPSP C 4 O 6 H 1
LOAD rho.cube
LOAD elf.cube
XDM GRID elf 2
~~~
This generates several cube files: root-tau.cube, root-pdens.cube,
root-core.cube, root-lap.cube, root-grad.cube, and
root-b.cube. Subsequent runs can circumvent the calculation of B,
PDENS, and CORE by doing:

~~~
CRYSTAL rho.cube
ZPSP C 4 O 6 H 1
LOAD rho.cube
LOAD root-b.cube
LOAD root-pdens.cube
LOAD root-core.cube
XDM GRID XB 2 PDENS 3 CORE 4
~~~
Note that passing RHO 1 is not necessary because rho.cube is the first
field loaded (hence the reference) and assumed by default to be the
density by XDM. Again: the ZPSP of all atoms are needed for an XDM
calculation. Also, only closed-shell (non-spinpolarized) systems can
be calculated for now. During the calculation, cubes for almost all
the properties above are generated so they can be reused in future
calculations. The other options are:
~~~
XA1 [a1.r]
~~~
The value of the a1 damping parameter (adimensional). Default:
0.6836 (PW86PBE parametrization for QE).
~~~
XA2 [a2.r]
~~~
The value of the a1 damping parameter (in angstrom). Default:
1.5045 (PW86PBE parametrization for QE).
~~~
ONLYC
~~~
Calculate the dispersion coefficients but not the dispersion
energy, forces, and stress. By default, they are calculated.
~~~
UPTO {6|8|10}
~~~
Only calculate the contributions to the energy coming from the C6
term (6), from the C6 and C8 terms (8) and from C6, C8, and C10
(10). The latter is the default.

### Control commands and options

~~~
ODE_MODE [METHOD {EULER|HEUN|BS|RKCK|DP}] [MAXSTEP maxstep.r] 
         [MAXERR maxerr.r] [GRADEPS gradeps.r]
~~~
Select the gradient path integration algorithm and its
parameters. EULER selects plain explicit Euler (1 evaulation per step)
with a poor man's technique for the step size adaptation. HEUN, Heun's
method (2 evaluations), with the same size adaptation as Euler's. BS,
Bogacki-Shampine's embedded 2(3)th-order method with error estimation
and first step as last. RKCK, Runge-Kutta-Cash-Karp embedded 4-5th
order method with local extrapolation and error estimate. DP,
Dormand-Prince 4-5th order with local extrapolation and error estimate
(7 evaluations per step). maxstep.r is the initial (and maximum) step
size (bohr in crystals, angstrom in molecules), gradeps.r is the
gradient norm termination criterion for the gradient path. maxerr.r is
the maximum error in the trajectory (in bohr). MAXERR only affects
methods that provide an error estimate for the predicted steps: BS,
RKCK, and DP.

This keyword applies to all gradient paths except those in qtree. The
defaults are BS method with maxstep.r = 0.3 bohr, gradeps.r = 1e-7,
and maxerr.r = 1e-5.

~~~
PRUNE_DISTANCE prune.r
~~~
Prune gradient paths so that only one point is plotted every prune.r
distance (units: bohr in crystals and angstrom in molecules, default:
0.1 bohr). Gradient paths are forced to have steps of length less than
or equal to prune.r. Therefore, a very small PRUNE_DISTANCE will
result in slow gradient path tracing.

~~~
INT_RADIAL [TYPE {GAULEG|QAGS|QNG|QAG}] [NR nr.r]
           [ABSERR aerr.r] [RELERR rerr.r]
           [ERRPROP prop.i]
           [PREC delta.r]
~~~
Choose the radial integration method (e.g. inside spheres or
basins). The TYPE keyword selects the qudrature method:

+ GAULEG: Gauss-Legendre.

+ QAGS: quadpack's dqags (general-purpose, extrapolation, globally
  adaptive, end-point singularities). All Q methods are sometimes
  unstable for heavy atoms and big beta-spheres, but this does not
  happen very often.

+ QNG: quadpack's dqng (smooth integrand, non-adaptive,
  Gauss-Kronrod(Patterson))

+ QAG: quadpack's dqag (general-purpose, integrand examiner,
  globally adaptive, Gauss-Kronrod)

The number of radial integration points, if appropriate (GAULEG,QAG)
is selected with NR. If the selected method is QAG, the number of
points may vary from nr.r. The allowed intervals are: 7 - 15, 10 -
21, 15 - 31, 20 - 41, 25 - 51, 30 - 61. Critic2 selects the
appropriate interval by comparing the given nr.r to the lower
limits of these intervals.

ABSERR is the requested absolute error for QUADPACK
integrators. RELERR is the requested relative error for QUADPACK
integrators. ERRPROP controls the property for which the error is
estimated. If prop.i corresponds to one of the integrable properties
then RELERR and ABSERR apply only to it. The selected property
guides the adaptive integration procedure. If prop.i does not
represent one of the integrable properties, the maximum of the
absolute value of the properties vector is used.  Note : the option
where max(abs(prop)) is used is unstable. Some spheres (usually
associated to heavy atoms) may integrate to nonsense, depending on
the optimization levels of the compiler. Therefore, I have disabled
it by default.

In the case of basin integrations, PREC controls the precision in
the determination of the interatomic surface (bohr in crystal,
angstrom in molecules).

Default: GAULEG, nr.r = 50, aerr.r = 1d0, rerr.r = 1d-12. The default
errprop is the field value and the Laplacian. delta.r = 1e-5 bohr.

~~~
MESHTYPE {BECKE|FRANCHINI {1|2|3|4|5}}
~~~
Choose the type and quality of the molecular integration mesh. These
meshes are used in molecular and crystals to calculate integrals over
the whole space (cell in crystals, R3 in molecules - used in XDM), and
for the MESH seeding option in AUTO.

+ BECKE: Becke-style integration grids with the same quality
  parameters as in postg. As currently implemented, it is quite slow
  and only available for molecules. If this option is chosen,
  FRANCHINI 3 is used by default for crystals. 

+ FRANCHINI: a Becke-style molecular mesh with weights and quality 
  parameters adapted from Franchini et al. J. Comput. Chem. 34 (2013)
  1819. Works for molecules and crystals, and it is relatively
  efficient. No pruning is done yet. The number after the keyword is
  hte quality selector, that controls the size of the mesh and the
  accuracy of the integration.  The values are 1 (small), 2 (normal),
  3 (good), 4(very good), 5 (excellent).

Default: FRANCHINI with lvl = 3 (good accuracy).

~~~
PRECISECUBE|STANDARDCUBE
~~~
The field values in cube files written by Gaussian are written in
exponential format with six significan digits. This precision may not
be enough for some applications, particularly involving energies. The
default behavior of critic2 (corresponding to the PRECISECUBE keyword)
is to write cubes with 14 significant digits. Some other programs that
use Gaussian cube files may not like this, however, so the keyword
STANDARDCUBE is provided to make critic2 write cube files in the
default Gaussian format.

~~~
BONDFACTOR bondfactor.r
~~~
Critic2 considers two atoms are covalently bonded if their distance is
less than the sum of their covalent radii times bondfactor.r (default:
1.4). The maximum bondfactor allowed is 2.0.

~~~
RADII [at1.s|z1.i] rad1.r [[at2.s|z2.i] rad2.r ...]
~~~
Sets the covalent radii of atoms with atomic symbol at1.s or atomic
number z1.i to rad1.r. (Units: bohr in crystals, angstroms in
molecules). The radii of several atoms can be changed in the same
command.

~~~
ROOT root.s
~~~
Change the <root>. The root is used as prefix for most of the
auxiliary files written by critic2.

~~~
SUM [id.s]
MAX [id.s]
MIN [id.s]
MEAN [id.s]
COUNT id.s eps.r
~~~
Using the field on a grid id.s, calculate the sum of the node values
(SUM), the maximum value (MAX), the minimum (MIN), the average
(MEAN), or count the number of elements that are greater than eps.r
(COUNT). If no id.s is given in the first four commands, use the
reference field. 

~~~
BENCHMARK [nn.i]
~~~
Benchmark the speed of the field calculation using nn.i points
(default: 10000)

~~~
{RUN|SYSTEM} command.s
~~~
Execute a shell command.

~~~
ECHO string.s
~~~
Write the string to the output. Useful for partitioning long outputs.

~~~
expression.s
~~~
If the input is not identified as any of the keywords above, then
evaluate the line as an arithmetic expression. Useful for
simple calculations in the command line (with critic2 -q).

~~~
END
~~~
Terminates the execution.

## Appendix

### Related programs and output file formats

Some programs required or just useful when working with critic2 are:

- **gnuplot**: most of the output critic2 creates are text files with
  column organized grid data, readily formatted to use with
  gnuplot. Also, in some tasks, critic2 also generates the gnuplot
  scripts required for the representation.

- **geomview**: some atomic basin plots are created in geomview's OFF
  and COFF format, which are described below.

- **tessel**: tessel is a generalized plotting program for crystal
  structures. Critic2 provides input files for tessel (mainly in
  FLUXPRINT). Also, BASIN and DBASIN files, containing the information
  about the atomic basins are generated, which are read and plotted by
  tessel.

- **avogadro**: can be used to manipulate xyz files for nciplot.

The description of the output file formats in critic2 follows.

#### INT files

The INT files contain a description of an IAS surface for a number of
rays. The rays are given by a fixed 2d angular quadrature, specified
in the first line of the file. The successive lines are the r_ias, in
the precise order needed. Only for internal use of CRITIC.

#### BASIN files

The surface of an atomic basin is approximated in critic2 by a
polyhedron, with vertices on the rays on which the zero-flux surface
has been determined. This surface, named basin from now on, is
approximately described as a number of polygonal facets, each being a
ordered list of vertices.

Let us consider, in addition, several scalar properties evaluated
on the vertices of the surface. We can select any of this properties to
create a color map of the scalar property on the basin surface.

This files can only be used to analyze those surfaces that are
monovalued in spherical coordinates (i.e. surfaces that have
one and only one value of the radial coordinate for every angular
point).

The structure of the BASIN files is:

- **Rec. 0** : "#" comment.

  Comment lines starting with "#" may appear anywhere.

- **Rec. 1** : nvert, nface, nedge

  Number of vertices, faces and edges of the polyhedron.

- **Rec. 2**: npropty

  Number of properties (scalars or scalar components) that will
  be given for each point.

- **Rec. 3** : (propname(i), i = 1, npropty)

  Alphanumerical label for each property. Blank characters (one or
  more) separate the properties.
  Notice that vectors are given as three separate components, etc.

- **Rec. 4i, i = 0, nvert-1** : x(i), y(i), z(i), (prop(j,i),j=1,npropty)

  For each vertex: the Cartesian coordinates and the values of
  all the properties given for this point.

- **Rec. 5j, j = 0, nface-1** : nv, (ivert(k,j), k=1,nv)

  The number of vertices of this face is nv (nv=3 in the
  triangular tesselations and 4 in the quadrilateral ones).
  For each vertex in this face, the number of order in the
  previous vertex list. Remember that vertices are numbered
  from 0 to nvert-1.

#### DBASIN files

The DBASIN files contain the description of the basin of a point,
and the value of a scalar property inside the basin (e.g. the
electron density). Those data are used to plot the surfaces of
constant value of the scalar property.

A regular grid of NPOINT points is defined along each ray from
the origin (excluded) to the limit of the basin for this ray.
The scalar property is computed in these points. Notice that the grid
is, in principle, different for each ray.

The structure of a DBASIN file is:

- **Rec. 0** : "#" comment

  Comment lines starting with "#" may appear anywhere.

- **Rec. 1** : nvert, nface, nedge

  Number of vertices, faces and edges of the polyhedron.

- **Rec. 2** : npoint, xnuc, ynuc, znuc, rhonuc

  Number of sampled points along each ray. Cartesian (x,y,z) position
  of the nucleus. Electron density at the nucleus.

- **Rec. 3i, i = 0, nvert-1** : x(i), y(i), z(i), (rho(j,i),j=1,npoint)

  For each vertex: the Cartesian coordinates and the values of
  the electron density at the grid points.

- **Rec. 4j, j = 0, nface-1**: nv, (ivert(k,j), k=1,nv)

  The number of vertices of this face is nv (nv=3 in the
  triangular tesselations and 4 in the quadrilateral ones).
  For each vertex in this face, the number of order in the
  previous vertex list. Remember that vertices are numbered
  from 0 to nvert-1.

#### OFF and COFF files

The OFF/COFF files can be viewed and printed with geomview. The
structure is:

- **Rec. 0** : "#" comment.

  Comment lines starting with "#" may appear anywhere.

- **Rec. 1** : file_type

  Either OFF or COFF keyword.

- **Rec. 2** : nvert, nface, nedge

  Number of vertices, faces and edges of the polyhedron.

- **Rec. 3** : (x(i),y(i),z(i), [r(i),g(i),b(i),alpha(i)],i = 0, nvert-1)

  Cartesian coordinates (x,y,z) of the vertices. In the case of
  COFF files, additional information is given regarding the
  RGB color associated to the vertex, and the degree of
  transparency (alpha) of the surface at this position.

- **Rec. 4j, j = 0, nface-1** : nv, (ivert(k,j), k=1,nv)

  The number of vertices of this face is nv (nv=3 in the
  triangular tesselations and 4 in the quadrilateral ones).
  For each vertex in this face, the number of order in the
  previous vertex list. Remember that vertices are numbered
  from 0 to nvert-1.

## Keyword list

ATOMLABEL
  Relabel the atoms in the current structure `Relabel the atoms in the
  structure (ATOMLABEL)`_. 

AUTO
  Determine the position and properties of the critical points.
  See `Automatic determination of critical points (AUTO)`_.

BADER
  Integrate the attraction (atomic) basins of a field defined on a
  grid using Henkelman et al.'s method. See `Henkelman et al. method
  (BADER)`_.

BASINPLOT
  Three-dimensional plots of the attraction basins. See `Attractor
  basin plots (BASINPLOT)`_.

BENCHMARK
  Run a benchmark test to measure the evaluation cost of the reference
  field. Mostly for debug purposes. See `Control commands and
  options`_.

BONDFACTOR
  Two atoms are considered covalently bonded if their distance is less
  than the sum of their covalent radii times BONDFACTOR. See `Control
  commands and options`_.

BUNDLEPLOT
  Three-dimensional plot of a primary bundle. See `Primary bundle
  plots (BUNDLEPLOT)`_.

CLEAR
  Clear the value of a variable. See `Arithmetic expressions,
  variables, and functions in critic2`_.

CLEARSYM
  Delete all symmetry operations except the identity. See `Symmetry
  options`_.

CLEARSYMM
  Same as CLEARSYM.

COMPARE
  Compare two or more crystal structures using their powder
  diffraction patterns. See `Compare crystal structures (COMPARE)`_.

COUNT
  Count the number of nodes of a field defined on a grid that are
  greater than a certain value. See `Control commands and options`_.

CPREPORT
  Print additional information (including three-dimensional plots)
  about the critical point list. See `Requesting more information
  about the critical point list (CPREPORT)`_.

CRYSTAL
  Load a crystal structure. See `The crystal structure`_.

CUBE
  Write a file containing the values of a field on a three-dimensional
  grid. See `Grids (CUBE)`_.

ECHO
  Write a message to the critic2 output. See `Control commands and
  options`_.

END
  Terminates the critic2 run. See `Control commands and options`_.

ENVIRON
  Calculate the nearest neighbors of the atoms in the crystal
  structure. See `Other structural tools (NEWCELL, ENVIRON, PACKING,
  IDENTIFY, EWALD)`_. 

EWALD
  Calculate the electrostatic energy by performing an Ewald
  summation. See `Other structural tools (NEWCELL, ENVIRON, PACKING,
  IDENTIFY, EWALD)`_. 

FLUXPRINT
  Three-dimensional representations of the current field's gradient
  paths. See `Three-dimensional gradient path representations
  (FLUXPRINT)`_.

GRDVEC
  Two-dimensional representations of the reference field, comprising
  contour lines, gradient paths, or a combination of the two. See
  `Gradient path representations in a plane (GRDVEC)`_.

SYMM
  Activate the use of the symmetry module that lets critic2 determine
  the space group operations of a crystal structure. See `Symmetry
  options`_.

HIRSHFELD
  Calculate the Hirshfeld (stockholder) charges. See `Hirshfeld
  charges (HIRSHFELD)`_.

IDENTIFY
  Identify the position of an atom or a critical point given in
  crystallographic or cartesian coordinates. See `Other structural
  tools (NEWCELL, ENVIRON, PACKING, IDENTIFY, EWALD)`_.

INTEGRABLE
  Mark a field as a property to be integrated in the attraction
  basins. See `List of properties integrated in the attractor basins
  (INTEGRABLE)`_.

INTEGRALS
  Integrate the basins of the reference field by bisection. See
  `Bisection (INTEGRALS and SPHEREINTEGRALS)`_.

INT_RADIAL
  Radial integration method used in bisection. See `Control commands
  and options`_.

LIBRARY
  Define the path to the library file. See `The crystal library
  (CRYSTAL LIBRARY)`_ and `The molecular library (MOLECULE
  LIBRARY)`_. 

LINE
  Calculate the values of a field on a line. See `Lines (LINE)`_.

LIST
  List all defined variables and named fields. See `Arithmetic
  expressions, variables, and functions in critic2`_.

LOAD
  Load a scalar field. See `Loading a field (LOAD)`_.

MAX
  Find the maximum value of a field defined on a grid. See `Control
  commands and options`_.

MEAN
  Find the average of a field defined on a grid. See `Control commands
  and options`_.

MESHTYPE
  Type and quality of the molecular integration mesh. See `Control
  commands and options`_.

MIN
  Find the minimum value of a field defined on a grid. See `Control
  commands and options`_.

MOLCELL
  Define the molecular cell. See `The molecular structure`_ and `The
  molecular cell`_.

MOLECULE
  Load a molecular structure. See `The molecular structure`_.

NCIPLOT
  Make a non-covalent interaction plot. See `Non-covalent interaction
  visualization (NCIPLOT)`_.

NEWCELL
  Change the cell setting of the current crystal structure by defining
  a new unit cell. See `Other structural tools (NEWCELL, ENVIRON,
  PACKING, IDENTIFY, EWALD)`_.

NOCORE
  Clears the pseudopotential charge (ZPSP) of all atoms, deactivating
  the use of the core contribution. See `Atomic charge options`_.

NOSYMM
  Deactivate the use of the symmetry module that lets critic2
  determine the space group operations of a crystal structure. See
  `Symmetry options`_.

ODE_MODE
  Choose the numerical method for gradient path tracing. See `Control
  commands and options`_.

PACKING
  Calculate the packing ratio of the current crystal structure. See
  `Other structural tools (NEWCELL, ENVIRON, PACKING, IDENTIFY,
  EWALD)`_. 

PLANE
  Write a file containing the values of a field on a plane and,
  optionally, make a contour plot. See `Planes and contour plots
  (PLANE)`_

POINT
  Write the properties (value, derivatives, related quantities) of one
  or more fields at a given point. See `Points (POINT)`_.

POINTPROP
  Defines the list of properties to be calculated at critical
  points (AUTO) and through the use of the POINT keyword. See `List of
  properties calculated at points (POINTPROP)`_.

POWDER
  Calculate the powder diffraction pattern of the current crystal
  structure. See `Powder diffraction (POWDER)`_.

Q
  Define the atomic charges. See `Atomic charge options`_.

QAT
  Same as Q.

QTREE
  Integrate the attractor basins using the qtree method. See `Qtree
  (QTREE)`_.

RADII
  Sets the covalent radii of atoms. See `Control commands and options`_.

REFERENCE
  Mark a field as the reference field. See `The reference field
  (REFERENCE)`_.

RESET
  Restart the critic2 run by clearing all structural and field
  information. See `Loading multiple crystal structures`_.

ROOT
  Change the default prefix for the files generated by critic2. See
  `Control commands and options`_.

RUN
  Run an external command. See `Control commands and options`_.

SETFIELD
  Change field flags after the field was loaded. See `Changing the
  field options after LOAD (SETFIELD)`_.

SPHEREINTEGRALS
  Integrate fields on a sphere. See `Bisection (INTEGRALS and
  SPHEREINTEGRALS)`_.

STM
  Make scanning tunneling microscopy plots. `Scanning Tunneling
  Microscopy plots (STM)`_.

SUM
  Sum of the values of a field defined on a grid. See `Control
  commands and options`_.

SYSTEM
  Same as RUN; run an external command. See `Control commands and
  options`_.

UNITS
  Change the default units used in the input and output. See `Input
  and output units`_.

UNLOAD
  Unload a field. See `Unloading a field (UNLOAD)`_.

WRITE
  Write the crystal structure to an external file. See `Exporting the
  structure (WRITE)`_.

XDM
  Calculate the XDM dispersion energy and derivatives. See `The
  exchange-hole dipole moment (XDM) model of dispersion`_.

YT
  Integrate the attraction (atomic) basins of a field defined on a
  grid using Yu and Trinkle's method. See `Yu and Trinkle (YT)`_

ZPSP
  Define the core contribution for an atom by setting the
  pseudopotential charge. See `Atomic charge options`_.

